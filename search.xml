<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ReactHook]]></title>
    <url>%2F2019%2F08%2F09%2FReactHook%2F</url>
    <content type="text"><![CDATA[什么是Hook他可以让你在不编写class的情况下使用 state 以及其他React特性 useState创建一个状态和更新状态的函数:useState唯一参数是初始state, 返回值为：当前state以及更新state的函数。 12345678910111213import React, &#123; useState &#125; from 'react';function Example() &#123; // 声明一个叫 "count" 的 state 变量, 默认值为0 const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 函数式更新如果新的state需要通过使用先前的satte计算得出, 那么可以将函数传递给 setState。 1return &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt; useEffectuseEffect 可以让你在函数组件中执行 副作用操作React 有另种副作用操作： 需要清除 和 不需要清除 的操作 不需要清除:1234567891011import React, &#123; useState, useEffect &#125; from 'react';function Example() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( // ... );&#125; 可以吧 useEffect Hook 看做 componentDidMount, componentDidUpdate 和 componentWillUnmount 三个函数的组合。默认情况下，它在第一次渲染之后和每次更新之后都会执行。 需要清除如果你的 useEffect 返回一个函数，React 将会在执行清除操作时调用它 12345678910useEffect(() =&gt; &#123; function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); //订阅对应 componentDidMount 或者 componentDidUpdate 中的执行操作 return function cleanup() &#123; //清除操作对应class 中 componentWillUnmount 使用 ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;; &#125;); 通过跳过 Effect 进行性能优化在Class 模式中，有时候数据没变化不需要更新的时候，我们在 componentDidUpdate 中比较 prevProps 或者 prevState， 如果数据变化才更新。 12345componentDidUpdate(prevProps, prevState) &#123; if (prevState.count !== this.state.count) &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125;&#125; Effect Hook 中实现方式 123useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;, [count]); // 仅在 count 更改时执行 effect, 如果数组中有多个，只有一个改变也会执行 effect 如果 useEffect 第二个参数为 [] 空数组，则第一次渲染后，永远也不会触发。]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-事件驱动]]></title>
    <url>%2F2019%2F05%2F29%2Fnode-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[核心要点 node 是单进程单线程应用程序，但是通过事件和回调支持并发。 node 每一个API都是异步的，并作为一个独立线程运行。 node 基本上所有的事件机制都是用观察者模式实现。 内置事件处理 events模块1234const events = require('events');const eventEmitter = new events.EventEmitter();eventEmitter.on('eventName', eventHandler); //绑定事件处理程序eventEmitter.emit('eventName'); //触发事件处理程序 接收参数1234eventHandler(parms1, parms2)&#123; ...&#125;eventEmitter.emit('eventName', parms1, parms2); 其他方法123eventEmitter.addListener(eventName, eventHandler) //监听事件eventEmitter.on(eventName, eventHandler) //监听事件//两者无区别 1eventEmitter.once(eventName, eventHandler) //只会触发一次，自动解除监听 1eventEmitter.removeListener(eventName, eventHandler)//移除监听 error 事件EventEmitter 定义了一个特殊的事件 error, 当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。 1eventEmitter.emit('error'); //如果没有监听 'error' 则报错]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uni-app笔记]]></title>
    <url>%2F2019%2F03%2F26%2Funi-app%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[渐进式效果1234567891011&#123; "path": "pages/team/trackRecord", "style": &#123; "titleNView": &#123; "type": "transparent", "titleText": "业绩记录", "backgroundColor": "#4b74f2", "titleColor": "#fff" &#125; &#125; &#125;,]]></content>
      <tags>
        <tag>uni-app</tag>
        <tag>app</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌vpn]]></title>
    <url>%2F2019%2F02%2F23%2F%E8%B0%B7%E6%AD%8Cvpn%2F</url>
    <content type="text"><![CDATA[安装shadowsocks使用的是ubuntu16.4系统,使用root用户登录后输入一下命令 123wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 安装完成后，脚本提示如下 12345678Congratulations, Shadowsocks-python server install completed!Your Server IP :your_server_ipYour Server Port :your_server_portYour Password :your_passwordYour Encryption Method:your_encryption_methodWelcome to visit:https://teddysun.com/342.htmlEnjoy it! 卸载shadowsocks1./shadowsocks.sh uninstall 单用户配置配置文件路径：/etc/shadowsocks.json1234567891011&#123; "server":"0.0.0.0", "server_port":"your_server_port", "local_address":"127.0.0.1", "local_port":1080, "password":"your_password", "timeout":300, "method":"your_encryption_method", "fast_open": false&#125; 多用户配置配置文件路径：/etc/shadowsocks.json 123456789101112131415&#123; "server":"0.0.0.0", "local_address":"127.0.0.1", "local_port":1080, "port_password":&#123; "8989":"password0", "9001":"password1", "9002":"password2", "9003":"password3", "9004":"password4" &#125;, "timeout":300, "method":"your_encryption_method", "fast_open": false&#125; 使用指令启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart状态：/etc/init.d/shadowsocks status 客户端下载地址shadowsocks windowshadowsocks androidshadowsocks mac]]></content>
      <tags>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七牛域名回收解决]]></title>
    <url>%2F2018%2F12%2F10%2F%E4%B8%83%E7%89%9B%E5%9F%9F%E5%90%8D%E5%9B%9E%E6%94%B6%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[前言解决七牛测试域名回收，图片外链失效无法下载问题。 使用 qshell 克隆空间 首先安装 qshell 秘钥设置 1qshell account -- ak sk name 在 个人中心 &gt; 密钥管理 获取 ak sk，帐号名称 name 随便写 获取原空间文件名 列出原空间文件列表并保存到 list.txt 文件中1qshell listbucket 原bucket名 list.txt list.txt 文件中每行只保留文件名 1cat list.txt | awk '&#123;print $1&#125;' &gt;list_final.txt 这里会生成 list_final.txt 文件，全是格式化好的文件名称 复制原bucket到新bucket 1qshell batchcopy 原bucket名 新bucket名 list_final.txt 执行命令后克隆成功，如果有报错信息可能有图片克隆失败的情况 注意：这里两个bucket必须是同一地区。 下载 下载前首先在当前目录新建 download.txt 文件,然后在当前目录创建 img 目录 123456//download.txt&#123; &quot;dest_dir&quot;: &quot;./img/&quot;, #下载图片存放文件夹 &quot;bucket&quot;: &quot;yewenxiang&quot;, #需要下载的bucket空间名称 &quot;cdn_domain&quot;: &quot;pjiwcgz75.bkt.clouddn.com&quot; #需要下载的bucket空间外链，可在七牛查看&#125; 然后执行命令1qshell qdownload download.txt 这个bucket图片就全部下载在 img 文件中了。 使用已备案的域名绑定 在七牛的bucket中，点击绑定域名 点击创建，创建成功后复制 CNAME名称 由于我的域名是在阿里云注册的，所以要去阿里云域名控制台设置点击域名解析，添加一条 CNAME记录 记录值为在七牛复制的 CNAME值，主机记录需要和七牛中的名称一致，等待几分钟就绑定成功，使用 douban.ywx.store/文件名称 可访问图片。]]></content>
      <tags>
        <tag>七牛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron应用升级]]></title>
    <url>%2F2018%2F12%2F05%2FElectron%E5%BA%94%E7%94%A8%E5%8D%87%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[前言最近公司的一个vue项目，为了安全方面的考虑没有上传到服务器，每次打包需要群发，很是不方便，后来又考虑到使用 Electron打包成客户端，实现自动升级，在此做一些记录 桌面应用app图标图标分为三种，三个平台分别是： mac 的 .icns 后缀 window 的 .ico 后缀 (256x256px) linux 的 .png 后缀 (256x256px) .ico百度搜索有很多生成方式。 .icns生成: 在桌面新建 icons.iconset 文件夹,把原图片放在桌面。打开命令行cd到桌面，执行一下命令，生成不同尺寸的图片到 icons.iconset中 123456789101112sips -z 16 16 pic.png --out icons.iconset/icon_16x16.pngsips -z 32 32 pic.png --out icons.iconset/icon_16x16@2x.pngsips -z 32 32 pic.png --out icons.iconset/icon_32x32.pngsips -z 64 64 pic.png --out icons.iconset/icon_32x32@2x.pngsips -z 64 64 pic.png --out icons.iconset/icon_64x64.pngsips -z 128 128 pic.png --out icons.iconset/icon_64x64@2x.pngsips -z 128 128 pic.png --out icons.iconset/icon_128x128.pngsips -z 256 256 pic.png --out icons.iconset/icon_128x128@2x.pngsips -z 256 256 pic.png --out icons.iconset/icon_256x256.png sips -z 512 512 pic.png --out icons.iconset/icon_256x256@2x.png sips -z 512 512 pic.png --out icons.iconset/icon_512x512.pngsips -z 1024 1024 pic.png --out icons.iconset/icon_512x512@2x.png pic.png替换为你的图片文件路径，尺寸要求为1024x1024 然后生成 icns图标 1iconutil -c icns icons.iconset -o Icon.icns 目录结构 static 文件夹和 index.html 为vue打包好的文件 main.js 为程序主进程文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131// main.jsconst path = require('path');const url = require('url');const &#123; app, BrowserWindow, ipcMain, dialog, shell&#125; = require('electron');const &#123; autoUpdater &#125; = require('electron-updater');const feedUrl = `http://39.107.118.115:3000/$&#123;process.platform&#125;`;//这里39.107.118.115:3000 为服务端ip地址，需要再服务器上搭建一个静态服务器let isSetupFlash = falselet webContents;try &#123; app.commandLine.appendSwitch('ppapi-flash-path', app.getPath('pepperFlashSystemPlugin')) isSetupFlash = true&#125; catch (error) &#123; isSetupFlash = false&#125;let createWindow = () =&gt; &#123; let win = new BrowserWindow(&#123; maximizable: true, width: 1200, height: 800, minWidth: 1200, minHeight: 800, show: false, center: true, webPreferences: &#123; plugins: true &#125;, frame: true, &#125;); webContents = win.webContents; win.loadURL( url.format(&#123; pathname: path.join(__dirname, 'index.html'), //指定渲染进程入口文件 protocol: 'file:', slashes: true &#125;) ); win.on('closed', function() &#123; win = null &#125;) win.once('ready-to-show', () =&gt; &#123; win.show() &#125;)&#125;;let updateDescriptionlet checkForUpdates = () =&gt; &#123; //检测更新 autoUpdater.setFeedURL(feedUrl); //更新错误 autoUpdater.on('error', function(message) &#123; dialog.showErrorBox('更新错误！', '更新出错，请稍后再试') &#125;); //检测更新 autoUpdater.on('checking-for-update', function(message) &#123; &#125;); //可以更新 autoUpdater.on('update-available', function(message) &#123; updateDescription = message.description //打包后 dist/latest.yml 中增加description字段，可以填写更新的描述信息，更加友好。 &#125;); //不需更新 autoUpdater.on('update-not-available', function(message) &#123; &#125;); // 更新下载进度事件 autoUpdater.on('download-progress', function(progressObj) &#123; &#125;) //下载升级 autoUpdater.on('update-downloaded', function(event, releaseNotes, releaseName, releaseDate, updateUrl, quitAndUpdate) &#123; dialog.showMessageBox(&#123; type: 'info', title: '提示消息', message: ` 新版本已下载完成，是否现在退出并安装? 更新内容： $&#123;updateDescription&#125; `, buttons: ['yes', 'no'] &#125;, function(index) &#123; if (index === 0) &#123; autoUpdater.quitAndInstall(); &#125; &#125;) &#125;); //执行自动更新检查 autoUpdater.checkForUpdates();&#125;;app.on('ready', () =&gt; &#123; createWindow(); setTimeout(function() &#123; if (!isSetupFlash) &#123; dialog.showMessageBox(&#123; type: 'info', title: '提示消息', message: ` 检测到您系统中没有安装Flash，编辑器中的视频可能无法查看，是否去安装？ `, buttons: ['yes', 'no'] &#125;, function(index) &#123; if (index === 0) &#123; shell.openExternal('https://get2.adobe.com/cn/flashplayer/') app.quit() &#125; &#125;) &#125; checkForUpdates() &#125;, 1000);&#125;);app.on('window-all-closed', () =&gt; &#123; if (process.platform !== 'darwin') &#123; app.quit() &#125;&#125;);app.on('activate', function() &#123; if (mainWindow === null) &#123; createWindow() &#125;&#125;) 1234567891011121314151617181920212223242526272829303132333435&#123; "name": "electrontoydb", "version": "1.0.5", "description": "...", //程序的描述，需要填写。 "main": "main.js", //指定主进程入口文件 "scripts": &#123; "dev": "node_modules/.bin/electron .", "build": "rimraf dist &amp;&amp; electron-builder -w" &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "electron": "^3.0.7", "electron-builder": "^20.29.0", "rimraf": "^2.6.2" &#125;, "dependencies": &#123; "electron-updater": "^3.1.6" &#125;, "build": &#123; "productName": "..", //打包软件名称 "appId": "com.toydb.app", "win": &#123; "icon": "icon/icon.ico" //windows软件图标路径 &#125;, "mac": &#123; "icon": "icon/icon.icns" // mac图标路径 &#125;, "publish": [&#123; "provider": "generic", "url": "http://39.107.118.115:3000" //指定更新的地址 &#125;] &#125;&#125; 在打包后，上传dist 中的四个文件到服务器 win32文件夹下 苹果应用也是一样。 需要注意的是：每次打包升级需要修改 package.json 文件中的 version 版本号，例如：1.0.0 –&gt; 1.0.1。]]></content>
      <categories>
        <category>pc</category>
      </categories>
      <tags>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron入门]]></title>
    <url>%2F2018%2F10%2F31%2FElectron%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[创建electron 项目使用 electron-forge 创建项目12npm install -g electron-forgeelectron-forge init my-app 手动创建package.json 文件中的main字段，必须是electron主进程文件，也就是main.js(或者index.js) 123456789101112131415161718192021222324252627282930313233343536//main.js 主进程文件var electron = require('electron')var app = electron.app //创建elecgtron引用var BrowserWindow = electron.BrowserWindow //创建BrowsetWindow引用var mainWindow = null //变量来保存对应窗口的引用app.on('ready', function()&#123; //创建 BrowserWindow 的实例赋值给win 打开窗口 mainWindow = new BrowserWindow(&#123; width:400, height: 400, &#125;) mainWindow.loadFile('index.html') //把index.html文件加载到主窗口 mainWindow.webContents.openDevTools() //开启调试模式 mainWindow.on('close', () =&gt; &#123; mainWindow = null //关闭窗口时，回收变量。 &#125;)&#125;)// 当全部窗口关闭时退出。app.on('window-all-closed', () =&gt; &#123; // 在 macOS 上，除非用户用 Cmd + Q 确定地退出， // 否则绝大部分应用及其菜单栏会保持激活。 if (process.platform !== 'darwin') &#123; app.quit() &#125;&#125;)app.on('activate', () =&gt; &#123; // 在macOS上，当单击dock图标并且没有其他窗口打开时， // 通常在应用程序中重新创建一个窗口。 if (win === null) &#123; createWindow() &#125;&#125;) 目录结构: 1234.├── index.html├── main.js└── package.json 官方推荐在项目中安装 electron，而不是在全局。 1npm i electron -D 运行 1234//package.json"scripts": &#123; "start": "./node_modules/.bin/electron ."&#125;, Electron 运行流程首先开启主进程去找当前目录下的 package.json 中的main字段的入口文件 index.html 找到后载入并开启渲染进程。 渲染进程和主进程的介绍： 1234567.├── index.html├── main #主进程js文件夹├── main.js├── node_modules├── package.json└── renderer #渲染进程js文件夹 主进程：package.json文件中 main 字段指向的文件，如果指向main.js，那main.js和它所引入的js文件，全部为主进程代码。渲染进程：在main.js 文件中 mainWindow.loadFile(&#39;index.html&#39;) 所引入的html文件中所引入的js文件为渲染进程文件。 操作本地文件demo在electron项目中，主进程和渲染进程都可以调用Node模块，（主进程为main.js文件中执行的代码, 渲染进程为 index.html中视图文件），一般新建一个renderer文件夹写在渲染进程中 12345├── index.html├── main.js├── package.json└── renderer └── index.js 123456&lt;!--index.html--&gt;&lt;body&gt; &lt;button id="btn"&gt;获取package.json&lt;/button&gt; &lt;textarea id="textarea" cols="40" rows="20"&gt;&lt;/textarea&gt; &lt;script src="./renderer/index.js"&gt;&lt;/script&gt;&lt;/body&gt; 1234567891011//renderer/index.jsvar fs = require('fs')window.onload = function()&#123; var btn = window.document.querySelector('#btn') var textarea = window.document.querySelector('#textarea') btn.onclick = function()&#123; fs.readFile('package.json', (err, data) =&gt; &#123; textarea.innerHTML = data &#125;) &#125;&#125; 实现拖拽打开文件demo1234&lt;body&gt; &lt;div class="content" id="content"&gt;&lt;/div&gt; &lt;script src="./renderer/index.js"&gt;&lt;/script&gt;&lt;/body&gt; 1234567891011121314//renderer/index.jsvar fs = require('fs')var content = document.querySelector('#content')content.ondragenter = content.ondragover = content.ondragleave = function()&#123; return false&#125;content.ondrop = function(e)&#123; e.preventDefault() console.log(e.dataTransfer.files[0]) var path = e.dataTransfer.files[0].path fs.readFile(path, 'utf-8', (err, data) =&gt; &#123; content.innerHTML = data &#125;)&#125; 主进程和渲染进程通信主要使用了两个模块 ipcRenderer 和 ipcMain模块。 异步通信123456789//渲染进程var &#123; ipcRenderer &#125; = require('electron')var sendDom = document.querySelector('#btn2')sendDom.onclick = function()&#123; ipcRenderer.send('sendM', 123) //渲染进程给主进程广播事件&#125;ipcRenderer.on('replay', (event, value) =&gt; &#123; //接收主进程的回复 console.log(value)&#125;) 12345678//主进程var &#123; ipcMain &#125; = require('electron')ipcMain.on('sendM', (event,value) =&gt; &#123; console.log(event) console.log(value) //123 event.sender.send('replay', 'ok') //给渲染进程回复消息&#125;) 同步通信1234567//渲染进程var &#123; ipcRenderer &#125; = require('electron')var sendDom = document.querySelector('#btn2')sendDom.onclick = function()&#123; const msg = ipcRenderer.sendSync('asyncSendM', 123) console.log(msg) //同步通信&#125; 12345//主进程var &#123; ipcMain &#125; = require('electron')ipcMain.on('asyncSendM', (event, value) =&gt; &#123; event.returnValue = '同步通信'&#125;) 渲染进程和渲染进程之间的通信场景：多个新窗口之间的通信 解决方法: 使用HTML5 localStorage 来实现多个窗口的传值通信 通过 BrowserWindow 和 webContents 模块来实现 通过 BrowserWindow 和 webContents 模块来实现，通俗的来讲，是通过 ipcRenderer.send 把值传给主进程，然后主进程通过 win.webContents.send(params),传递给 win 这个窗口。 123456789//主进程win = new BrowserWindow(&#123; width:300, height:300,&#125;)win.loadFile('news.html')win.webContents.on('did-finish-load', function()&#123; //窗口加载完毕后传值 win.webContents.send('toNews',params)&#125;) 12345//渲染进程var &#123; ipcRenderer &#125; = require('electron)ipcRenderer.on('toNews', function(event, params)&#123; console.log(params) &#125;) 消息如何回传？ 比如 渲染线程A 和渲染线程B，下面简称A、B当A向B传递参数，如果需要回传参数，那么，在传递参数的时候带上当前渲染线程（A）的ID12//主线程const winId = BrowserWindow.getFocusedWindow().id //获取渲染线程A的ID 在渲染线程B中使用 BrowserWindow.fromId(winId) 来获取渲染线程A的窗口实例123var BrowserWindow = require('electron').remote.BrowserWindow//由于 BrowserWindow 是主线程中的模块 所以在渲染线程中使用的时候，需要借助于 remote 模块来调用let win = BrowserWindow.fromId(winId) 后面的步骤和上面类似了 123456//渲染线程Bwin.webContents.send('toA',params) //传递消息//渲染线程AipcRenderer.on('toA', function(event, params)&#123; //接收消息 console.log(params) &#125;) Electron 模块 主进程中使用的模块 渲染进程中使用的模块 都可以使用的模块 模块可以让我们用js调用或者操作电脑上某一部分原生的功能。 remote模块渲染进程和主进程中进行进程通讯(IPC)的通讯模块，可以让我们在渲染进程中调用主进程的方法。 打开新窗口demo12345678910111213141516var btn = document.querySelector('#btn')var BrowserWindow = require('electron').remote.BrowserWindowvar win=nullbtn.onclick = function()&#123; win = new BrowserWindow(&#123; width:400, height:300, // frame:false, //去掉顶部关闭条 // fullscreen: true, //全屏 &#125;) win.loadFile('news.html') win.on('closed',() =&gt; &#123; win = null &#125;)&#125; menu模块可以自定义软件菜单，注意，如果在渲染模块中定义会出现软件打开时，能看到初始菜单的情况，所以，最好在主线程中去定义菜单选项 123456789101112131415161718192021222324252627282930313233343536//定义菜单模块const &#123;Menu&#125; = require('electron')const template = [ &#123; label: '文件', submenu: [ &#123; label: '新建文件', accelerator: 'command+n' //自定义快捷键 &#125;, &#123; label: '新建窗口' &#125; ] &#125;, &#123; label: '编辑', submenu: [ &#123; label: '复制', role: 'copy', // 内置快捷键 click: function()&#123; //自定义事件 console.log('111') &#125; &#125;, &#123; label: '新建窗口', click: function()&#123; console.log('111') &#125; &#125; ] &#125;]const menu = Menu.buildFromTemplate(template)Menu.setApplicationMenu(menu) 别忘了在主线程中的 main.js 中引入文件 require(&#39;./main/Menu.js&#39;)! 右键菜单1234567891011121314&lt;!-- index.html --&gt; &lt;script&gt; const &#123;remote&#125; = require('electron') const &#123;Menu, MenuItem&#125; = remote const menu = new Menu() menu.append(new MenuItem(&#123;label: 'MenuItem1', click() &#123; console.log('item 1 clicked') &#125;&#125;)) menu.append(new MenuItem(&#123;type: 'separator'&#125;)) menu.append(new MenuItem(&#123;label: 'MenuItem2', type: 'checkbox', checked: true&#125;)) window.addEventListener('contextmenu', (e) =&gt; &#123; e.preventDefault() menu.popup(&#123;window: remote.getCurrentWindow()&#125;) &#125;, false) &lt;/script&gt;]]></content>
      <categories>
        <category>pc</category>
      </categories>
      <tags>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex入门]]></title>
    <url>%2F2018%2F10%2F19%2FVuex%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简单的例子1234567891011121314151617//store/index.jsimport Vuex from 'vuex'import Vue from 'vue'Vue.use(Vuex)const store = () =&gt; &#123; return new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment(state) &#123; state.count++ &#125; &#125; &#125;)&#125;export default store 123//组件this.$store.state.count //获取状态this.$store.commit('increment') //修改状态 State 和 mapStates最简单的方法是在 计算属性 中返回某个状态 12345computed: &#123; count() &#123; return this.$store.state.count &#125;&#125; 但是状态多了之后，都申明为计算属性，显得会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性。 12345678import &#123; mapState &#125; from 'vuex'export default &#123; //... computed: &#123; ...mapState(['count']) &#125;&#125; mapState函数返回一个对象，通过对象结构的方式合并到computed中。 Getter 和 mapGettersgetter可以认为是 store 的计算属性。 创建Getter1234567891011const store = new Vuex.Store(&#123; state: &#123; name: 'yewenxiang', age: 18 &#125;, getters: &#123; people(state, getters) &#123; //getters表示其他getter return `name:$&#123;state.name&#125;, age:$&#123;state.age&#125;` &#125; &#125;&#125;) Getter传参可以通过让getter返回一个函数，来实现给getter传参 12345678//创建getters: &#123; people: (state) =&gt; (id) =&gt; &#123; return console.log(id, state) &#125;&#125;//使用this.$store.getters.people(1) //不管state值是否改变，都会调用 使用Getter普通方式使用 12345computed:&#123; people()&#123; return this.$store.getters.people &#125;&#125; mapGetters方式使用 1234computed:&#123; //... ...mapGetters(['people'])&#125; Mutation 和 mapMutations更改Vuex的store中的状态只能使用mutation来更改，便于状态追踪和调试。 创建Mutation1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state, params) &#123; //params 为自己所传递参数 // 变更状态 state.count++ &#125; &#125;&#125;) 使用Mutation普通方式使用1this.$store.commit('increment'， params) // 大多数情况params为对象 mapMutations方式使用 123456789import &#123; mapMutations &#125; from 'vuex'export default &#123;//...methods:&#123; ...mapMutations(['increment']) // 将 `this.increment()` 映射为 `this.$store.commit('increment')`&#125;//...&#125; Mutation 使用规范 Mutation 必须是同步函数 每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照，如果异步修改状态，当 mutation 触发的时候，状态还没有被修改，导致此时的状态的改变不可通过devtools追踪。 使用常量替代 Mutation 事件类型。 建立 mutation-types.js 文件， Mutation 需遵守 Vue 的响应规则。 提前在你的 store 中初始化好所有所需属性。 在对象上添加新属性时应该使用 Vue.set(obj, &#39;newProp&#39;, 123) 或者 对象展开运算符 来合并。 Action 和 mapActionsAction 类似于 mutation，不同在于： Action 提交的是 mutation, 而不是直接变更状态。 Action 可以包含任意的异步操作 创建一个异步的actions12345678910111213141516171819202122const store = () =&gt; &#123; return new Vuex.Store(&#123; state: &#123; count: 0, name: 'yewenxiang', age: 18 &#125;, mutations: &#123; increment(state) &#123; state.count++ state.age++ &#125; &#125;, actions: &#123; asyncIncrement(context) &#123; setTimeout(function() &#123; context.commit('increment') &#125;, 2000) &#125; &#125; &#125;)&#125; context包含： commit 提交 mutation dispatch 提交 action getters rootGetters rootState state 可以使用 this.$store.dispatch(&#39;xxx&#39;) 来分发 action， 或者使用 mapActions。 123456methods: &#123; ...mapActions(['asyncIncrement']), //将 `this.asyncIncrement()` 映射为 `this.$store.dispatch('asyncIncrement')` addCount() &#123; this.asyncIncrement() &#125;&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nuxt入门]]></title>
    <url>%2F2018%2F10%2F12%2FNuxt%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[全局CSS 默认情况下 Nuxt 使用 vue-loader、file-loader 以及 url-loader 这几个 Webpack 加载器来处理文件的加载和引用。对于不需要通过 Webpack 处理的静态资源文件，可以放置在 static 目录中。 12//nuxt.config.jscss:['~assets/css/main.css'] 路由传参路由和vue中类似，不过Nuxt是根据page目录来动态生成路由表的，不需要我们配置。 12345&lt;ul&gt; &lt;li&gt;&lt;nuxt-link to="/"&gt;home&lt;/nuxt-link&gt;&lt;/li&gt; &lt;li&gt;&lt;nuxt-link :to="&#123;name: 'about', params:&#123;id: 1&#125;&#125;"&gt;about&lt;/nuxt-link&gt;&lt;/li&gt; &lt;li&gt;&lt;nuxt-link to="views"&gt;views&lt;/nuxt-link&gt;&lt;/li&gt;&lt;/ul&gt; 动态路由在路由里面定义带参数的动态路由。需要创建以下划线为前缀的Vue文件或目录 写法一：1&lt;nuxt-link :to="'/community/member/'+ user.id"&gt; 写法二：1&lt;nuxt-link :to="&#123;name:'news-id', params:&#123;id: 123&#125;&#125;"&gt;新闻1&lt;/nuxt-link&gt; news这里是路由名称后面注意加上 -id,代表传的参数为 id字段，使用_id动态路由文件。 js跳转 123go(id) &#123; this.$router.push(&#123; path: '/comments/' + id &#125;)&#125; 动态路由参数校验对于动态路由传递的参数，进行校验 1234567&lt;script&gt;export default &#123; validate(&#123; params &#125;) &#123; return /^\d+$/.test(params.id) //返回false 跳转到404 &#125;&#125;&lt;/script&gt; 路由切换动画效果全局路由添加动画需要添加全局的CSS类,如下 123456.page-enter-active, .page-leave-active &#123; transition: opacity 2s;&#125;.page-enter, .page-leave-active &#123; opacity: 0;&#125; 单个动画切换添加一个唯一的类，并绑定到组件中 12345678.test-enter-active, .test-leave-active &#123; transition: all 2s; font-size:12px;&#125;.test-enter, .test-leave-active &#123; opacity: 0; font-size:40px;&#125; 在需要动画效果的路由中绑定类12345&lt;script&gt;export default &#123; transition: 'test'&#125;&lt;/script&gt; 默认模板和默认布局有时候页面中有一些公共的头部或者尾部，这时候可以考虑使用默认模板，或者默认布局 默认模板使用默认模板，需要在应用的根目录下创建一个 app.html 的文件 1234567891011&lt;!--app.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &#123;&#123; HEAD &#125;&#125; &lt;!--对应nuxt.config.js中的head字段,必须大写--&gt;&lt;/head&gt;&lt;body&gt; &lt;P&gt;测试&lt;/P&gt; &lt;!--公共头部--&gt; &#123;&#123; APP &#125;&#125; &lt;!--APP代表page中的组件，必须大写--&gt;&lt;/body&gt;&lt;/html&gt; 默认布局123456&lt;template&gt; &lt;div&gt; &lt;p&gt;测试&lt;/p&gt; &lt;!--公共的头部--&gt; &lt;nuxt/&gt; &lt;!--页面主体内容--&gt; &lt;/div&gt;&lt;/template&gt; 区别：模板可以定制很多头部信息（比如IE版本判断），默认布局只能定义页面body中的元素 自定义错误页面nuxt是有默认的错误页面的，有时间需要自定义就需要在 /layouts/ 目录下建立一个error.vue 文件, 它相当于一个显示错误的组件。 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;h2 v-if=&quot;error.statusCode==404&quot;&gt;404页面不存在&lt;/h2&gt; &lt;h2 v-else&gt;500服务器错误&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;nuxt-link to=&quot;/&quot;&gt;HOME&lt;/nuxt-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:[&apos;error&apos;],&#125;&lt;/script&gt; 个性meta设置在 nuxt.config.js 中 head字段设置的是全局头，如何针对单个页面进行设置？ 123456789101112&lt;script&gt;export default &#123; hear()&#123; return&#123; title:'个性标题', meta:[ &#123;hid:'description',name:'news',content:'This is news page'&#125; ] &#125; &#125;&#125;&lt;/script&gt; 这里hid:&#39;description&#39;是一个唯一标识符，需要和全局的hid值相同，才会覆盖全局的值。 异步请求数据12345678910111213&lt;script&gt; export default &#123; data()&#123; return &#123; &#125; &#125;, async asyncData() &#123; let &#123; data &#125; = await axios.get('https://api.myjson.com/bins/8gdmr') return &#123; info: data &#125; &#125; &#125;&lt;/script&gt; 由于请求数据时组件不存在，这里也就没有this，return 的对象会直接合并到 data中, 在模板中直接绑定数据即可。 Nuxt升级使用命令 1npm upgrade 不能直接只升级nuxt，以上命令出问题，最好删除 lock-package.json 文件]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>SSR</tag>
        <tag>Nuxt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面hack]]></title>
    <url>%2F2018%2F10%2F10%2F%E9%A1%B5%E9%9D%A2hack%2F</url>
    <content type="text"><![CDATA[弹窗后禁止页面滚动首先考虑的是 1234body &#123; overflow-x: hidden; overflow-y: hidden;&#125; 但是这种方法，在关闭弹窗时页面出现滚动条会导致页面偏移，影响用户体验。 对于偏移的问题可以设置body的padding-right:15px，来解决。但是在不同的浏览器中的滚动条宽度不一，还是会导致几个像素的偏移。 完美解决办法：动态的计算滚动条的宽度，然后设置padding值 123.fancybox-lock-test &#123; overflow-y: hidden !important;&#125; 12345678910var w1 = $(window).width()Dom.htmlDom.addClass('fancybox-lock-test')var w2 = $(window).width()Dom.htmlDom.removeClass('fancybox-lock-test')$("&lt;style type='text/css'&gt;.fancybox-margin&#123;margin-right:" + (w2 - w1) + "px;&#125;&lt;/style&gt;").appendTo("head")Dom.bodyDom.addClass('fancybox-margin')$('body').css(&#123; "overflow-x": "hidden", "overflow-y": "hidden",&#125;); 图片懒加载解决的问题：对于大图首次加载产生白屏的问题。 解决的思路：把大图压缩到几十KB，也就是当做缩略图来展示，首次加载缩略图，加载完毕之后再加载真实的高清图，减少白屏时间，提升用户体验。 12&lt;img class="introduce-1-img thumbnails" src="https://i.toydb.cn/1-introduce_1_min.jpg" data-img="https://i.toydb.cn/1-introduce_1.png" alt=""&gt; 1234.thumbnails &#123; filter: blur(4px); /*图片产生模糊效果*/ transition: all 0.7s;&#125; 12345678910111213var thumbImg = $('.thumbnails') //所有需要懒加载的图片for (var i = 0; i &lt; thumbImg.length; i++) &#123; (function (i) &#123; var imgObject = new Image(); var currentImg = thumbImg.eq(i); var img = currentImg.data('img'); imgObject.src = img imgObject.onload = function () &#123; currentImg.attr("src", img) currentImg.css("filter", "blur(0)") &#125; &#125;)(i)&#125; 移动端rem布局对于页面切图不要使用750pxPSD设计图，在dpr=3的高清屏下，图片可能存在不清晰的情况,切完图片后，在把PSD图片调回 750px宽度，加入下面JS代码，计算值为 rem=设计图px/100 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114(function(win, lib) &#123; var doc = win.document; var docEl = doc.documentElement; var metaEl = doc.querySelector('meta[name="viewport"]'); var flexibleEl = doc.querySelector('meta[name="flexible"]'); var dpr = 0; var scale = 0; var tid; var flexible = lib.flexible || (lib.flexible = &#123;&#125;); if (metaEl) &#123; var match = metaEl.getAttribute('content').match(/initial\-scale=([\d\.]+)/); if (match) &#123; scale = parseFloat(match[1]); dpr = parseInt(1 / scale); &#125; &#125; else if (flexibleEl) &#123; var content = flexibleEl.getAttribute('content'); if (content) &#123; var initialDpr = content.match(/initial\-dpr=([\d\.]+)/); var maximumDpr = content.match(/maximum\-dpr=([\d\.]+)/); if (initialDpr) &#123; dpr = parseFloat(initialDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; if (maximumDpr) &#123; dpr = parseFloat(maximumDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; &#125; &#125; if (!dpr &amp;&amp; !scale) &#123; var isAndroid = win.navigator.appVersion.match(/android/gi); var isIPhone = win.navigator.appVersion.match(/iphone/gi); var devicePixelRatio = win.devicePixelRatio; if (isIPhone) &#123; // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案 if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) &#123; dpr = 3; &#125; else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2)) &#123; dpr = 2; &#125; else &#123; dpr = 1; &#125; &#125; else &#123; // 其他设备下，仍旧使用1倍的方案 dpr = 1; &#125; scale = 1 / dpr; &#125; docEl.setAttribute('data-dpr', dpr); if (!metaEl) &#123; metaEl = doc.createElement('meta'); metaEl.setAttribute('name', 'viewport'); metaEl.setAttribute('content', 'initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no'); if (docEl.firstElementChild) &#123; docEl.firstElementChild.appendChild(metaEl); &#125; else &#123; var wrap = doc.createElement('div'); wrap.appendChild(metaEl); doc.write(wrap.innerHTML); &#125; &#125; function refreshRem() &#123; var width = docEl.getBoundingClientRect().width; // 适配平板 if (width / dpr &gt; 750) &#123; width = 750 * dpr; &#125; var rem = 100 * (width / 750); docEl.style.fontSize = rem + 'px'; flexible.rem = win.rem = rem; &#125; win.addEventListener('resize', function() &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125;, false); win.addEventListener('pageshow', function(e) &#123; if (e.persisted) &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125; &#125;, false); if (doc.readyState === 'complete') &#123; doc.body.style.fontSize = 12 * dpr + 'px'; &#125; else &#123; doc.addEventListener('DOMContentLoaded', function(e) &#123; doc.body.style.fontSize = 12 * dpr + 'px'; &#125;, false); &#125; refreshRem(); flexible.dpr = win.dpr = dpr; flexible.refreshRem = refreshRem; flexible.rem2px = function(d) &#123; var val = parseFloat(d) * this.rem; if (typeof d === 'string' &amp;&amp; d.match(/rem$/)) &#123; val += 'px'; &#125; return val; &#125; flexible.px2rem = function(d) &#123; var val = parseFloat(d) / this.rem; if (typeof d === 'string' &amp;&amp; d.match(/px$/)) &#123; val += 'rem'; &#125; return val; &#125; &#125;)(window, window['lib'] || (window['lib'] = &#123;&#125;));]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序基本知识]]></title>
    <url>%2F2018%2F09%2F29%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[常用快捷键 按F1查看快捷键命令(fn + f1) command + e 查看最近打开的文件 command + p 搜索文件 小程序尺寸和单位设计原则在小程序中单位主要分为两种 px 和 rpx， rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。 微信小程序的设计图最好是以iphone6屏幕尺寸来设计，也就是750 * 1334的尺寸。因为这个尺寸在布局中可以避免计算的麻烦，直接按照设计图的px尺寸来换算, 1rpx = 1px(iphone6 设计图), 如果在小程序中要使用px单位，则需要(设计图px / 2)来计算，因为iphone6的像素密度为 2dpi, 也就是1px等于2倍的物理像素。 小程序大部分的情况下是使用rpx为单位，好处是尺寸随设备的dpi变化，而变化，不用去考虑响应式。如果不希望放大缩小，就需要使用px为单位。 page样式的巧妙应用有时间需要定义全局的样式时候，可以在根目录 app.wxss 中这么定义 1234page &#123; font-family: "PingFangSC-Thin"; font-size:32rpx;&#125; 因为小程序所有组件都是引入到 page页面中，而page页面最顶层是一个page标签，这些属性被后面的标签所继承(如 font-… 、 color ，会从组件外继承到组件内)。 根目录 .wxss 中的类，只能在page中去使用，无法在组件中使用. 相对路径和绝对路径在小程序中，组件可以使用绝对路径和相对路径，但是对于自己封装的模块，使用import引入的时候只能使用相对路径 1234567&#123; "usingComponents":&#123; "v-like": "/components/like/index" &#125;&#125;import &#123;HTTP&#125; from '../../util/http.js' 自定义组件自定义组件触发事件使用场景：子组件的业务，需要交给父组件去执行。 为什么要如此？对于一个通用组件来说，把数据请求写组件中是不明智的，如果这个组件在其他的项目中去使用的话，api地址，参数等等，都不一样，没有复用性。就算在同一个项目中，不同的类别可能api也不同。所以最好的方式是，这部分业务逻辑交写在父组件里面，子组件只包含能共用的基本逻辑。 自定义组件触发事件时，需要使用 triggerEvent 方法，来激活父组件中所绑定自定义的事件，同时传递当前子组件的一些内部状态给父组件。 12//子组件中this.triggerEvent('like',&#123;behavior&#125;,&#123;&#125;) 第一个参数为自定义事件名, 第二个参数是传递给父组件的一些参数（子组件的内部状态），在父组件中通过 event.detail 字段来获取, 第三个参数为 触发事件的选项参考 12//父组件.wxml，这里v-like为子组件，like为自定义事件名。&lt;v-like bind:like="onLike"&gt; 12345678910//父组件.jsPage(&#123; //... onLike: function (event) &#123; console.log(event.detail) //子组件传递过来的参数 //执行业务逻辑 &#125; //...&#125;) observer当组件中的从外部传递进来的属性值值被触发修改时，会执行这个函数 1234567891011properties: &#123; idnex: &#123; type: String, observer: function(newVal, oldVal, changedPath)&#123; let val = newVal &lt; 10? '0' + newVal: newVal this.setData(&#123; index: val //这里会发生内存泄漏... &#125;) &#125; &#125;&#125; behaviors组件间代码共享 behaviors可以包含 properties、data、生命周期方法（和组件所包含的方法、属性一样）。 每个组件可以引用多个behavior behavior可以引用其他behavior behavior需要使用 Behavior()构造器定义 使用示例: 1234567891011121314151617//classic-beh.jslet classicBeh = Behavior(&#123; behaviors: [], properties: &#123; img: String, content: String &#125;, data: &#123; myBehaviorData: &#123;&#125; &#125;, attached: function()&#123;&#125;, methods: &#123; myBehaviorMethod: function()&#123;&#125; &#125;&#125;)export &#123; classicBeh &#125; behaviors覆盖规则组件和他引用的behavior 中可以包含同名字段，对这些字段的处理方法如下： 如果有同名的属性或方法、组件本身的属性或方法是优先使用的。 如果一个组件引用了了多个 behavior, behaviors: [myBehavior1,myBehavior2], 数组中越靠后的覆盖前面的属性和方法 如果同名的数据字段是对象类型，会进行对象合并，如果是非对象类型则会进行相互覆盖 生命周期函数不会相互覆盖，而是多次被调用。 slot 插槽通俗点来说，就是从组件的外部传递标签，到组件的内部来显示, &lt;slot name=&quot;&quot;&gt;&lt;/slot&gt; 标签在哪，传进来的标签位置就在哪。（可以在组件内部就写好，通过properties来控制显示和隐藏,但是slot更加的灵活）不传递的时候slot就是一组空插槽，并且不会显示。 使用组件slot插槽 12345//子组件组件.wxss&lt;view class="container"&gt; &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt; &lt;slot name="after"&gt;&lt;/slot&gt;&lt;/view&gt; 组件启用slot插槽功能1234//子组件.jsoptions: &#123; multipleSlots:true // 在组件定义时的选项中启用slot支持,单个多个slot都需设置&#125;, 1234//父组件&lt;v-tag text="&#123;&#123;content&#125;&#125;"&gt; &lt;text slot="after"&gt;&#123;&#123;nums&#125;&#125;&lt;/text&gt;&lt;/v-tag&gt; 传递外部样式一般写业务代码时候，可以直接通过CSS选择器，来强行修改组件内部的样式，但是如果对于开源的组件，就需要使用小程序传递样式类的这种机制 1234//子组件.jsComponent(&#123; externalClasses: ['tag-class']&#125;) 12345//子组件.wxml&lt;view class="container tag-class"&gt; &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt; &lt;slot name="after"&gt;&lt;/slot&gt;&lt;/view&gt; class=”container tag-class” 这里并不会因为.tag-class在.container后面,后面的样式会覆盖前面的情况。小程序目前没有这种机制，需要去增加 .tag-class的权重去覆盖，比如 ！important 1234//父组件.wxml&lt;v-tag tag-class="ex-tag" text="&#123;&#123;content&#125;&#125;"&gt; &lt;text class="num" slot="after"&gt;+&#123;&#123;nums&#125;&#125;&lt;/text&gt;&lt;/v-tag&gt; 父组件.wxss123.ex-tag &#123; background-color: #fffbdd !important;&#125; properties和data组件中如果打印 this.properties 或 this.data 会发现它们是同一个对象，这是小程序内部的一个机制，他会把这两个对象合并成一个。如出现重名： 123456properties: &#123; //properties会覆盖掉data中的index index:Number&#125;,data: &#123; index: 0&#125; 引用公共的样式如果多个组件的样式中有重复的样式，可以提取出来，放在一个单独的.wxss文件中，在组件的 .wxss分别取引入 1@import "../common.wxss"; 页面中传递参数通过生命周期方法中 ‘onLoad’ 来接收 1234//页面跳转传递参数wx.navigateTo(&#123; url: `/page/book-detail/book-detail?id=$&#123;id&#125;`&#125;) 1234//接收参数onLoad(option)&#123; const id = option.id&#125; wxswxs是小程序一套脚本语言，可以使wxml具备编写js或调用js的能力，主要是结合wxml来使用，可以写在wxml文件中，或者单独建立一个wxs文件中。 wxs是借鉴了js的语法，但是和js有很大的不同，无法使用es6的语法。 建立单个文件好处是方便各个组件的wxml来调用123456789101112//filter.wxsvar format = function(text)&#123; if(!text)&#123; //会执行两次，第一次undefined报错 return &#125; var reg = getRegExp('\\\\n', 'g') return text.replace(reg, '\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;')&#125;module.exports = &#123; //导出函数,无法使用es6语法 format:format, limit:limit&#125; 调用 1234&lt;wxs src="../../util/filter.wxs" module="util" /&gt;&lt;!--这里的module是自定义的命名--&gt;&lt;text class="content" decode="&#123;&#123;true&#125;&#125;"&gt;&#123;&#123;util.format(book.summary)&#125;&#125;&lt;/text&gt;&lt;!--decode="&#123;&#123;true&#125;&#125;" 开启转义空格 &amp;nbsp;--&gt; wxml内编写wxs如果在全局只有当前组件使用，可考虑内联的写法。12345678&lt;!--wxml--&gt;&lt;wxs module="m1"&gt;var msg = "hello world";module.exports.message = msg;&lt;/wxs&gt;&lt;view&gt; &#123;&#123;m1.message&#125;&#125; &lt;/view&gt;]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象和面向过程]]></title>
    <url>%2F2018%2F09%2F29%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[面向过程（Procedure-oriented）比如写3个对输入框输入数据校验功能的方法，用了3个函数这是一种面向过程的实现方式。 弊端： 无端的在页面中添加了很多全局变量。 不利于别人重复利用 一旦别人使用你以前提供的方法，你就不能轻易的去修改这些方法，不利于团队代码维护 面向对象面向对象：就是将你的需求抽象成一个对象，然后针对这个对象分析其特征（属性）和动作（方法），这个对象我们称之为类 封装：就是把你需要的功能放在一个对象里 通过 this 添加的属性和方法同在prototype中添加的属性和方法有什么区别？通过this 添加的属性和方法是在当前对象添加的，prototype中添加的属性和方法不是对象自身的，而是对象继承而来的，也就是每个对象通过prototype访问到的，所以我们我们每次通过类创建一个新对象时，这些属性和方法不会再次创建 类的私有变量和私有方法由于JS的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的，通过这个特性来创建类的私有变量和私有方法。 类的公有变量和公有方法在函数内部通过this创建的属性和方法，在类创建对象时，每个对象都拥有一份并且可以在外部访问到。 因此通过对象创建的属性可看做是对象的共有属性和共有方法 类的特权方法通过this创建的方法，不但能访问对象的公有属性和公有方法，而且还能访问到 父类或者对象自身 的私有属性和私有方法，由于这些方法权利比较大，所以称之为特权方法 类的构造器在对象创建时通过使用 特权方法 我们可以初始化实例对象的一些属性，因此这些在创建对象时调用的特权方法还可以看作是类的构造器 123456789101112var Book = function(id, name, price)&#123; var num = 1; //私有属性 function checkId()&#123;&#125; //私有方法 this.id = id; //公有属性 this.copy = function()&#123;&#125; //公有方法 this.getName = function()&#123; //特权方法 //在函数内能访问创建出来对象的公有属性和公有方法，还能访问到父类或者对象自身的私有属性和私有方法 &#125; this.getName(name) //构造器&#125; 类的静态共有属性和类的共有静态方法静态共有属性和类的共有静态方法： 通过类在外面通过点语法定义的属性以及方法 通过new关键字创建新的对象时，由于类外面通过点语法添加的属性和方法没有执行到，所以新创建的对象中无法获取他们，但是可以通过类来使用。 类的共有属性和共有方法类通过prototype 创建的属性或者方法，在类实例的对象中是可以通过this访问到的，所以把prototype对象中的属性和方法称为共有属性和共有方法。 123456789Book.isChinese = true; //类静态共有属性（子类对象不能访问）Book.resetTime = function()&#123; //类静态共有方法（子类对象不能访问） console.log('new Time')&#125;Book.proptype = &#123; isJSBook:false, //共有属性 display:function()&#123;&#125; //共有方法&#125; 通过new 关键字创建的对象实质是对新对象this的不断赋值，并将prototype指向类的prototype 所指的对象。 创建对象的安全模式123456789var Book = funtion(title,name,type)&#123; if(this instanceof Book)&#123; //判断执行过程中this是否指向当前对象（如果是说明是当前对象，如果没有使用new，this指向的是window对象） this.title = title; this.time = time; this.type = type; &#125;else &#123; return new Book(title,name,type) &#125;&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[生成器Generators]]></title>
    <url>%2F2018%2F09%2F29%2F%E7%94%9F%E6%88%90%E5%99%A8Generators%2F</url>
    <content type="text"><![CDATA[什么是生成器?12345678function* quips(name) &#123; yield `你好$&#123;name&#125;!` yield `这是一个生成器Generators` if(name.startsWith('y'))&#123; yield `你的名字$&#123;name&#125;首字母是y` &#125; yield '我们下次再见'&#125; 这段代码称为生成器函数，与普通函数的区别： 普通函数使用function声明,生成器函数使用 function*声明 在生成器函数内部，关键字 yield 类似于普通函数的 return 。普通函数只能 return 一次，而生成器函数可以 yield 一次或者多次。在生成器执行的过程中，遇到 yield表达式立即暂停，后续可恢复执行状态 最大区别：普通函数不能自暂停，生成器函数可以。 生成器做了什么？1234567891011let value = quips('yewenxiang') //返回一个已暂停的生成器对象console.log(value.next())//&#123;value: "你好yewenxiang!", done: false&#125;console.log(value.next())//&#123;value: "这是一个生成器Generators", done: false&#125;console.log(value.next())//&#123;value: "你的名字yewenxiang首字母是y", done: false&#125;console.log(value.next())//&#123;value: "我们下次再见", done: false&#125;console.log(value.next())//&#123;value: undefined, done: true&#125; 上面调用 quips(&#39;yewenxiang&#39;)时，并非立即执行，而是返回一个已暂停的生成器对象，并且赋值给了 value 每当你调用生成器对象的 .next() 方法时，函数调用将其自身解冻并一直运行到下一个yield表达式，再次暂停。 专业术语描述: 每当生成器执行yields语句，生成器的堆栈结构（本地变量、参数、临时值、生成器内部当前执行的位置）被移出堆栈。然而，生成器对象保留了这个堆栈结构的引用，所以后面调用 .next() 可以重新激活堆栈结构并且继续执行。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Symbol的理解]]></title>
    <url>%2F2018%2F09%2F29%2FSymbol%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Symbol是什么 它是JavaScript的第七种原始类型（ES6新特性，Symbol也是值，不是字符串，也不是对象。） Symbol 为什么会出现？ 它能避免命名冲突 获取Symbol的三种方式 调用Symbol() 这种方式每次调用都会返回一个新的唯一Symbol 调用Smybol.for(string) 这种方式会访问Symbol注册表，其中储存了已经存在的一系列Symbol。这种方式与Symbol()定义的独立Symbol不同，Symbol()每次调用都返回一个新的并且唯一的Symbol。如果连续调用 Symbol.for(‘ye’),每次都会返回相同的Symbol。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[this的理解]]></title>
    <url>%2F2018%2F09%2F29%2Fthis%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[this的定义 this的定义 this是在 执行上下文 创建时确定的一个在执行过程中不可更改的变量** 执行上下文 执行上下文就是JavaScript引擎在执行一段代码之前将代码内部会用到的一些变量、函数、this提前声明然后保存在变量对象中的过程。 this只在 函数调用阶段确定 ，也就是执行上下文创建的阶段进行赋值，保存在变量对象中。这个特性也导致了this的多变性:函数在不同的调用方式下都可能会导致this的值不同 严格模式和非严格模式的区别1234567var a = 1;function fun() &#123; 'use strict'; var a = 2; return this.a;&#125;fun();//😨报错 Cannot read property 'a' of undefined 123456var a = 1;function fun() &#123; var a = 2; return this.a;&#125;fun();//1 结论：当函数独立调用的时候，在严格模式下它的this指向undefined，在非严格模式下，当this指向undefined的时候，自动指向全局对象(浏览器中就是window) 在对象中使用this1234567891011121314var a = 1000;var obj = &#123; a:1, b:this.a + 1&#125;function func() &#123; var obj = &#123; a:1, c:this.a + 2 &#125; return obj.c&#125;console.log(func()); //1002console.log(obj.b); //1001 结论: 当obj在全局声明的时候,obj内部属性中的this指向全局对象，当obj在一个函数中声明时，严格模式下this指向undefined,非严格模式自动转为window 一个例子加强理解1234567891011var a = 1;var obj = &#123; a:2, b:function()&#123; function fun() &#123; return this.a &#125; console.log(fun()) &#125;&#125;obj.b();//1 解析:这个例子中 fun函数在obj.b方法中定义,为什么结果为1呢，开始我觉得很奇怪，想通后就理解了,上面的结论, (当函数独立调用的时候，在严格模式下它的this指向undefined，在非严格模式下，当this指向undefined的时候，自动指向window) , fun函数是在 obj.b 函数中独立调用的，所以这里的this是指向window的 作为对象的方法12345678var a = 1;var obj = &#123; a: 2, b: function() &#123; return this.a; &#125;&#125;console.log(obj.b())//2 另一个例子加强理解 123456789var a = 1;var obj = &#123; a: 2, b: function() &#123; return this.a; &#125;&#125;var t = obj.b;console.log(t());//1 解释: obj.b属性储存的是对该匿名函数的一个引用（一个地址）,当赋值给t时，直接把地址复制给了t，调用t() 相当于直接调用了那个匿名函数 作为构造函数 如果函数作为构造函数使用，那么其中的this就代表它即将new出来的对象 1234567891011121314151617function Person()&#123; this.name = 'yewenxiang'; this.age = 24; this.sex = 'man'; this.run = function()&#123; return this.name + '正在跑步' &#125;&#125;Person.prototype = &#123; constructor : Person, say:function ()&#123; return this.name + '正在说话' &#125;&#125;var person1 = new Person()person1.run()person1.say() new 其实是一个语法糖 123456789101112131415//伪代码来看看new 做了什么function Person()&#123; //new 做的事情 var obj = &#123;&#125; obj.__proto__ = Person.prototype //继承原型上的方法和属性 obj.name = 'yewenxiang'; ... //对于构造函数中的this 一系列赋值, return obj&#125;//1.创建一个临时的对象//2.给临时对象绑定原型//3.给临时对象对应的属性赋值//4.返回一个临时对象 prototype对象的方法中的this指向实例对象，因为实例对象的proto已经指向了构造函数的prototype,方法会沿着原型链进行查找 箭头函数 箭头函数的this不是在调用时候确定的，这是箭头函数的好处之一，因为他的this不会变来变去。箭头函数会捕获其所在上下文的this的值,箭头函数this在词法层面就完成了绑定。apply,call方法只是传入参数，却改变不了this。]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js继承的几种方式]]></title>
    <url>%2F2018%2F09%2F29%2Fjs%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[类式继承（通过把父类的实例赋值给子类的原型来实现）1234567891011function SuperClass()&#123;&#125;SuperClass.prototype.book = ['JavaScript','HTML','CSS']function SubClass()&#123;&#125;SubClass.prototype = new SuperClass()var instance1 = new SubClass()var instance2 = new SubClass()console.log(instance1.book)instance2.book.push('yewenxiang')console.log(instance1.book) 缺点: 1.如果父类中共有属性要是有引用类型，在一个子类的实例更改了子类原型从父类构造函数，或者父类原型中继承来的共有属性，就会直接影响到其他子类 2.由于子类实现的继承是靠其原型prototype对父类的实例化实现的，因此在创建父类时，无法向父类传递参数，因而在实例化父类的时候也无法对父类构造函数内的属性传递参数初始化 构造函数继承 （通过在子类的构造函数调用父类的构造函数执行环境来实现继承）12345678910111213141516171819function SuperClass(id) &#123; this.book = ['JavaScript','HTML','CSS'] this.id = id&#125;SuperClass.prototype.showBook = function()&#123; console.log(this.book)&#125;function SubClass(id)&#123; SuperClass.call(this,id) //call可以更改函数的执行环境，因此在子类中，对superClass调用这个方法就是在子类中的变量在父类中执行一遍，由于父类中是给this绑定的属性，因此子类自然也继承了父类共有的属性&#125;var instance1 = new SubClass(10);var instance2 = new SubClass(11);instance1.book.push('yewenxiang')console.log(instance1.book) //["JavaScript", "HTML", "CSS", "yewenxiang"]console.log(instance1.id) //10console.log(instance2.book) //["JavaScript", "HTML", "CSS"]console.log(instance2.id) //11instance1.showBook() //TypeError 缺点: 这种类型的继承没有涉及原型，所以父类的原型方法自然不会被子类继承，如果想要被子类继承就必须放在构造函数中，这样创建出来的每个实例都会单独拥有一份而不能共用，违背了代码复用的原则 组合继承(结合了类式继承和构造函数继承的优点)12345678910111213141516171819202122232425function SuperClass(name)&#123; this.name = name; this.book = ['HTML','JavaScript','CSS']&#125;SuperClass.prototype.getName = function()&#123; console.log(this.name)&#125;function SubClass(name,time)&#123; SuperClass.call(this,name) this.time = time;&#125;SubClass.prototype = new SuperClass()SubClass.prototype.getTime = function()&#123; console.log(this.time)&#125;var instance1 = new SubClass('js book',2014)instance1.book.push('yewenxiang')console.log(instance1.book) //["HTML", "JavaScript", "CSS", "yewenxiang"]instance1.getName() //js bookinstance1.getTime() //2014var instance2 = new SubClass('css book',2015)console.log(instance2.book) //["HTML", "JavaScript", "CSS"]instance2.getName() //css bookinstance2.getTime() //2015 缺点: 在使用构造函数式继承时执行了一遍父类的构造函数，而实现子类原型的类式继承又调用了一遍父类的构造函数，因此父类构造函数调用了两遍，不是最完美的方式。 原型式继承（对类式继承的一个封装）1234567891011121314151617181920212223function inheritObject(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;var book = &#123; name:'js book', alikeBook:['css book','html book']&#125;var newBook = inheritObject(book)newBook.name = 'ajax book';newBook.alikeBook.push('xml book')var otherBook = inheritObject(book)otherBook.name = 'flash book';otherBook.alikeBook.push('as book')console.log(book.name) //js bookconsole.log(book.alikeBook) //["css book", "html book", "xml book", "as book"]console.log(newBook.name) //ajax bookconsole.log(newBook.alikeBook) //["css book", "html book", "xml book", "as book"]console.log(otherBook.name) //flash bookconsole.log(otherBook.alikeBook) //["css book", "html book", "xml book", "as book"] 优点: 和类式继承类似，不过由于F过渡类的构造函数无内容，开销比较小 缺点: 类式继承的缺点 寄生式继承 （对原型继承的二次封装）1234567891011var book = &#123; name:'js book', alikeBook:['css book','html book'] &#125;function createBook(obj)&#123; var o = new inheritObject(obj) o.getName = function()&#123; console.log(name) &#125; return o&#125; 解释: 对原型继承的二次封装,并在二次封装的过程中对继承的对象进行扩展，新创建的对象不仅有父类的属性和方法，而且添加了新的属性和方法 寄生组合式继承1234567891011121314151617181920212223242526272829303132333435363738function inheritObject(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;function inheritPrototype(subClass, superClass)&#123; var p = inheritObject(superClass.prototype) //复制一份父类的原型副本保存在变量中 p.constructor = subClass //修正因为重写子类原型导致子类的constructor属性被修改 subClass.prototype = p //设置子类的原型&#125;function SuperClass(name)&#123; this.name = name; this.color=['red','blue','green'];&#125;SuperClass.prototype.getName = function()&#123; console.log(this.name)&#125;function SubClass(name, time)&#123; SuperClass.call(this,name) this.time = time;&#125;inheritPrototype(SubClass,SuperClass)SubClass.prototype.getTime = function()&#123; console.log(this.time)&#125;var instance1 = new SubClass('js book', 2014)var instance2 = new SubClass('js book', 2015)instance1.color.push('black')console.log(instance1.color) //["red", "blue", "green", "black"]console.log(instance2.color) //["red", "blue", "green"]instance1.getTime() //2014instance2.getName() //js book 需要注意的是:子类想添加原型和方法必须通过 .prototype 来添加，直接赋予对象会覆盖掉从父类原型继承的对象了 多继承 单继承 123456var extend = function(target, source) &#123; for (var property in source)&#123; target[property] = source[property] &#125; return target&#125; 解释：就是对对象中的属性的一个复制过程，extends方法只是一个浅复制，只能复制值类型的属性，对于引用类型的无能为力，复制成功后，在新对象中修改了引用对象的值，原来的值也会改变。 多继承 实际上是在单继承的基础上多传入几个对象，做一些改变就实现了 1234567891011121314var mix = function()&#123; var i = 1, //从第二个参数起为被继承的对象，第一个参数为需要继承的对象 len = arguments.length, //获取所有被继承的对象数组 target = arguments[0], arg; //遍历被继承的对象数组 for(;i &lt; len; i++)&#123; arg = arguments[i]; //缓存当前对象 for (var property in arg)&#123; target[property] = arg[property]; &#125; &#125; return target&#125; 也可以绑定到原生对象Object上,这样所有的对象都拥有这个方法了 1234567891011Object.prototype.mix = function()&#123; var i = 0, //从第一个参数起为被继承对象 len = arguments.length, arg, for(;i &lt; len; i++)&#123; arg = arguments[i] for(var property in arg)&#123; this[property] = arg[property] &#125; &#125;&#125; 调用 1otherBook.mix(book1,book2)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native添加自定义图标]]></title>
    <url>%2F2018%2F09%2F29%2Freact-native%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[首先下载图标文件 阿里图标库 下载完毕后，只需要 iconfont.ttf 这个文件就行了。 IOS配置 首先建立一个 font 文件夹,里面放入 iconfont.ttf 打开 toydb.xcodeproj 文件 android 配置直接把 iconfont.ttf 放在 项目根目录/android/app/src/main/assets/fonts/ 中就行了 下一步使用 首先项目需要重新打包 react-native run-ios 然后，添加如下代码就OK了 1&lt;Text style=&#123;&#123;fontFamily:'iconfont'&#125;&#125;&gt;&amp;#xe603;&lt;/Text&gt; 图标字符可以点击下载的图标文件 demo_unicode.html 来查看]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的command]]></title>
    <url>%2F2018%2F09%2F29%2F%E5%B8%B8%E7%94%A8%E7%9A%84bash%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[升级react-native react-native-git-upgrade,直接升级到最新版本。升级到指定的版本 react-native-git-upgrade X.Y.Z。 升级时遇到的问题 ,删除掉 &quot;react-native-camera&quot;: &quot;git+https://github.com/lwansbrough/react-native-camera.git&quot;, 更新完成后，再安装 react-native-camera npm outdated 查看有哪些包可更新 npm-check -u 查看有哪些包可更新 npm list -g --depth 0 查看全局安装的包(depth 0 是只显示最顶层的包，不显示下面的依赖包) npm update 升级所有更新包,npm 2.6.1后才支持 yarn upgrade react-native-modalbox 升级包 which react-native 查看包的路径 mono --arch=32 Fiddler.exe 打开exe文件 lsof -i:端口号 kill -9 PID杀死进程 git 版本回滚 git reset --hard HEAD~0]]></content>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native-vector-icons用法]]></title>
    <url>%2F2018%2F09%2F29%2Freact-native-vector-icons%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[介绍react-native-vector-icons 是一个字体图标的库。 react-native-vector-icons 使用首先进入到项目目录 npm install react-native-vector-icons –save npm install rnpm -g rnpm link 然后在项目目录 打开demo/ios/demo.xcodeproj 文件，弹出xcode，右键工程文件Add Files to .. 选择 deno_modules/react-native-ver-icons/Fonts文件夹。 在xcode的Info.plist文件中,加入: Fonts provided by application数组,并根据需要加入以下9项: Entypo EvilIcons FontAwesome Foundation Ionicons MaterialIcons MaterialCommunityIcons Octicons Zocial SimpleLineIcons]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux]]></title>
    <url>%2F2018%2F09%2F29%2Fredux%2F</url>
    <content type="text"><![CDATA[数据流数据流是什么？为什么要用数据流？ 数据流是我们的行为与响应的抽象 使用数据流可以帮助我们明确行为对应的响应 React与数据流的关系 React 是纯V层的框架，不涉及任何的数据和控制，需要数据流进行支撑 主流数据流框架 Flux facebook 官方出的一个配合React来实现数据流的框架，属于单向数据流绑定，非常的大和重，实用性不强。 reFlux 属于 Flux 的一个第三方的框架。 redux 属于 Flux 的一个第三方的框架，简单 / 单一的状态树 单向数据流不只是前端，很多系统开发的时候遵从的都是MVC分离，也就是数据放在Model里面，View来控制显示，Controler做整体的管理。但是随着系统的庞大，它会产生一系列问题。比如举个例子，我们上网shopping，提交订单，那么用户的账号，优惠信息，物流信息，库存等等的Model都会发生更新变化，然后View上的显示也会随之变化，反过来，View的有些变化也会对Model产生影响，这样就使用户下了一个订单以后界面会变得什么样变得不可预测。 所以在React出现的同时Facebook也搞出了一个Flux 单向数据流 (React是纯V层框架，需要数据流进行支撑)，它的思想如下:它认为用户有各种各样的Action,然后所有的Action由一个统一的Dispacher分发到若干个Store里去，这个Store保存着数据也保存着页面的状态，根据数据和页面的状态，一个store只能向视图层传递信息，而不允许视图层再返回来作用到Store上，然后视图就发生更新，然后再由用户传入新的操作。这样子我们就能预测到Action作用到Store上时，View发生什么变化。 Redux是Flux的一种实现方法，但是也有些许不一样，它的思想如下 当页面渲染完，UI就出现了，然后用户触发UI上的Action，然后Action被送到Reducer这个方法里去，然后Reducer更新了Store，Store里包含react开发的State，最后State决定UI层的展现。这就是Redux的一个完整过程。 项目结构四个重要的文件夹 actions:用户的行为 components: container: reducer:负责分发axtions行为，根据用户的行为作出一个响应 index.html server.js webpack 安装 1$ yarn add --save redux react-redux redux本身就是一个工具流，而react-redux则是对redux的绑定。类似的还有ng2-redux、backbone-redux等 action 是行为的抽象 是普通的JS对象 一般由方法生成 1234567const addTodo = (text) =&gt; &#123; return &#123; type: 'ADD_TODO', id:nextTodoId++, text &#125;&#125; reducer 是响应的抽象 是纯方法 ： 可以完全的根据我们的输入来得到输出，非纯方法指的是，比如需要依赖系统的时间，依赖系统的状态。reducer里面只能是纯方法 传入旧状态state和action,返回新状态 1234567891011121314151617const todo = (state,action)=&gt;&#123; switch (action.type)&#123; case 'ADD_TODO': return&#123; id:action.id, text:action.text, completed:false &#125; case 'TOGGLE_TODO': if(state.id !== action.id)&#123; return state &#125; return Object.assign(&#123;&#125;,state,&#123;completed:!state.completed&#125;) default: return state &#125;&#125; storestore 可以看做是 state 和 reducer 的集合，state是运行的时候才会有的，我们定义好的只有 reducer , store 可以看做是所有数据和状态的存储 action 作用于 store reducer 根据store 响应 store 是唯一的 store 包括了完整的 state state 完全可预测 1234import &#123;createStore&#125; from "redux"import todoApp from "./reducers"let store = createStore(todoApp)//调用 createStore来生成 store，需要传 reducers]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pug]]></title>
    <url>%2F2018%2F09%2F29%2Fpug%2F</url>
    <content type="text"><![CDATA[命令行中的pug 安装pug全局安装pug12$ npm install --global pug$ npm install --global pug-cli 编译pug文件 1$ pug -P -w index.pug -P 编译后的html便于查看，保留空白节点 -w 持续监控文件修改，修改马上编译 类、ID、属性123h1#title(class=&apos;title2&apos;).title pug stydy#test.testinput(checked,value=&apos;ye&apos;) 编译后123&lt;h1 class="title2 title" id="title"&gt;pug stydy&lt;/h1&gt;&lt;div class="test" id="test"&gt;&lt;/div&gt;&lt;input checked value="ye"&gt; 属性一般在标签后的括号里面，用逗号隔开。 类和ID有点特殊，可以直接在标签后面以链接的形式来写，当然由于也属于属性，也可以使用括号包裹的写法 div标签可以省略， div#test.test 等价于 #test.test 。 对于没有属性值的直接写就行了，比如 input 里面的checked. 多行文本1234p | 1. aa | 2. bb | 3. cc 或者1234p. 1. aa 2. bb 3. cc 编译后12345&lt;p&gt; 1. aa 2. bb 3. cc&lt;/p&gt; 多行文本中标签的写法分成两种第一种是带点的纯文本的方式 第二种采用缩进的节点方式来写，把文本看做一个文本节点 注释 对于IE的条件注释)![pug5](./someImg/pug5.png 行内的style和script写法 声明变量和替换数据在html中声明变量括号里面可以对变量做一些js的处理 命令行中传值1$ pug -P -w index.pug --obj '&#123;"name":"xiangwang"&#125;' 可以看到页面中接收到了 name 这个变量的值 如果html中声明的变量和命令行中的变量同名，则html中的变量优先级高 通过json文件传变量创建一个json文件然后命令行中执行以下代码:1$ pug -P -w index.pug --O data.json 安全转义与非转义安全转义 也就是有时候我们希望页面中显示标签，也就是html中是转义后的字符。 非安全转义 有时候我们就是希望html中显示的就是标签 其他的方式和上面的结果一样12p= htmlDatap!= htmlData 如果我们有时候想页面中输出 #{}和!{} 怎么办呢？ 12p \#&#123;htmlData&#125;p !#&#123;htmlData&#125; 就显示成了 12&lt;p&gt;#&#123;htmlData&#125;&lt;/p&gt;&lt;p&gt;!&#123;htmlData&#125;&lt;/p&gt; 流程代码 for-each-whilefor和each的使用方式 white使用方式 流程代码 if-else-unless-swicif-else 的使用方式 unless（除非）如果是 false 就会往先执行12unless !what p #&#123;what.length&#125; case-whenswitch 语句是if-else-if 的兄弟语句,我们在 pug中可以使用 cass-when 来实现的 mixin使用 mixin 可以让pug的代码块重用,编译时会转换 javascript 中的函数，可以看做是一个函数，既然是函数，就可以传递参数 mixin的嵌套 内联mixin代码块 解释：调用 team函数的时候，下面包含一个 p Good job! 就代表代码块block，注意缩进关系。函数中说明的是，如果有代码块就执行代码块，否则执行p no team。 除了代码块和文本，mixin还支持传递属性，比如传递classname pug模板的继承pug通过 block 和 extends 这两个关键字来实现模板的继承，一个块可以看做是一个block，它在子模板中来实现，同时支持递归。 1234567891011//- layout.pughtml head title My Site - #&#123;title&#125; block scripts script(src=&apos;/jquery.js&apos;) body block content block foot #footer p some footer content 12//- pet.pugp= petName 123456789101112//- page-a.pugextends layout.pugblock scripts script(src=&apos;/jquery.js&apos;) script(src=&apos;/pets.js&apos;)block content h1= title - var pets = [&apos;cat&apos;, &apos;dog&apos;] each petName in pets include pet.pug include pet.pug 就相当于把 pet.pug中的内容放在了这里 编译 page-a.pug 后 page-a.html 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;title&gt;My Site - &lt;/title&gt; &lt;script src="/jquery.js"&gt;&lt;/script&gt; &lt;script src="/pets.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;cat&lt;/p&gt; &lt;p&gt;dog&lt;/p&gt; &lt;div id="footer"&gt; &lt;p&gt;some footer content&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; block 默认是替换replace，也就是不写的时候，当同名的时候会替换掉继承过来的 block，可以添加 prepend 或者 append 来实现 block 的合并 12345678//- layout.pughtml head block head script(src=&apos;/vendor/jquery.js&apos;) script(src=&apos;/vendor/caustic.js&apos;) body block content 123456//- page.pugextends layout.pugblock append head script(src=&apos;/vendor/three.js&apos;) script(src=&apos;/game.js&apos;) 编译 page.pug 后，生成 page.html 12345678910&lt;html&gt; &lt;head&gt; &lt;script src="/vendor/jquery.js"&gt;&lt;/script&gt; &lt;script src="/vendor/caustic.js"&gt;&lt;/script&gt; &lt;script src="/vendor/three.js"&gt;&lt;/script&gt; &lt;script src="/game.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; pug api有五个核心的API： pug.compile(source,options) source:string pug模板的字符 返回的是一个函数，这个函数是来生成HTML的，对这个函数也可以传入本地变量 eg pug.compile(&#39;div #{course}&#39;,{})({course:&#39;pug&#39;}) pug.compileFile(path,options) pug.compileClient(source,options) pug.render(source,options) source:string pug模板的字符 options 可以直接传入一个变量对象 例如 {course:&#39;pug&#39;} pug.renderFile(filename,options) source:string pug模板的路径 options 可以直接传入一个变量对象 例如 {course:&#39;pug&#39;} options参数是一个对象，可以设置以下属性，更多参考pugAPI filename:string 正在编译的文件的名称,默认为pug。 self:boolean 保持一个变量到 self 的 locals (命名空间) debug:boolean 开启调试模式]]></content>
      <tags>
        <tag>pug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp]]></title>
    <url>%2F2018%2F09%2F29%2Fgulp%2F</url>
    <content type="text"><![CDATA[gulp的安装第一步安装gulp自动化工具 1npm i -g gulp 第二步初始化项目仓库 12npm init在项目文件夹中输入，生成一个package.json 第三步在项目的文件中安装一个gulp 12npm i --save-dev gulp等价于 npm i -D gulp 第四步安装gulp-sass编译插件 1npm i -D gulp-sass gulp 的一些常用的插件 gulp-autoprefixer 主要给CSS文件中添加厂商前缀。 gulp-sass 把.scss或者.sass编译成.css文件。 gulp-imagemin 图片压缩工具，转换后大小变为原来的一般，图片质量不会损失。 gulp-browsersync 可以在本地搭建一个http服务器来，同时http开放链接，可以在手机等各个设备打开调试的页面，页面是的操作可以在各个设备上同步。 页面自动加载，也就是源码修改之后，页面不需要刷新就可以页面自动加载，可以同时在多个设备上完成。 gulp-wrap 把页面中一样的部分抽离出来，如 header footer 部分，我们只写页面主体内容，最后通过 gulp 加上 header footer。 gulp-minify-css 压缩css代码 gulp-purifycss 可以帮我们去除 html/js 页面中根本就没有用到的 CSS 代码（死代码？），想想，如果咱们的项目中用了 bootstrap.css ，肯定会有很多 css 代码是没用的。 gulp自动化脚本的写法脚本代码写在gulpfile.js文件中。可以使用 gulp.src 来选取文件，这样里面的数据就会形式“流”，沿着“管道”（ pipe ）一直向前，管道上的每个节点上我们都可以让一个插件发挥作用，然后处理后的数据最终通过 gulp.dest 导出到一个文件夹中。 12345678gulp.src('src/*.scss')//锁定我们要处理的一些文件.pipe(sass())//pipe（管道） 把文件交给工具流 sass 处理这些sass文件变成css文件.pipe(prefix())//接上一步的文件，添加厂商前缀.pipe(gulp.dest('css/'));//把最后处理好的文件导出到目标文件夹里面 gulp gulpfile.js 文件中常用写法1234567891011121314151617181920212223var gulp = require('gulp');var sass = require('gulp-sass');var prefix = require('gulp-autoprefixer');var minifyCss = require('gulp-minify-css');gulp.task('sass',function()&#123; gulp.src('src/main.scss') .pipe(sass()) //scss或者sass转化为 css 文件 .pipe(prefix()) // css文件中添加前缀 .pipe(minifyCss()) // css文件压缩 .pipe(gule.dest('dist/'));&#125;)//各个指令封装在 gulp.task之中，第一个参数为名字。//然后到命令行中打开有 gulpfile.js 文件的位置，执行 gulp sass 命令，会发现，main.scss 文件转化成了 main.css 放在 dist文件夹下了。gulp.task('copy-file',function()&#123; gulp.src('src/*.html') .pipe(gulp.dest('dist/'))&#125;)//定义一个拷贝文件的指令，把src文件夹下的所有 .html 文件拷贝到 dist文件夹下。gulp.task('default',['sass','copy-file'])//同时执行sass copy-file 两个动作,在 bash 中只用输入 gulp 或者 gulp default 就行了 使用 imagemin 来压缩图片需要安装两个包，一个是 gulp-imagemin ，另一个是 imagemin-pngquant(专门用来压缩PNG图片的 两个包配合使用)。 1cnpm i -D gulp-imagemin imagemin-pngquant gulpfile.js 中的内容 1234567891011121314//codevar imagemin = require('gulp-imagemin');var pngquant = require('imagemin-pngquant');gulp.task('imagemin', function()&#123; return gulp.src('src/images/*') .pipe(imagemin(&#123; progressive: true, svgoPlugins: [&#123;removeViewBox: false&#125;], use: [pngquant()] &#125;)) .pipe(gulp.dest('dist/images'));&#125;);//code 在命令行中输入 gulp imagemin 就可以压缩图片了。它会把 src/images 文件夹下面的所有图片全部压缩，放在了 dist/images 文件夹中。 更多文档参考github上的教程 imagemin]]></content>
      <categories>
        <category>自动化工具</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步加载、异步加载、延迟加载]]></title>
    <url>%2F2018%2F09%2F29%2F%E5%90%8C%E6%AD%A5%E5%8A%A0%E8%BD%BD%E3%80%81%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E3%80%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[同步加载平常默认用的都是同步加载。如：&lt;script src=&quot;http://XXX.com/script.js&quot;&gt;&lt;/script&gt;同步模式又称阻塞模式，会阻止浏览器的后续处理，停止了后续的文件的解析，执行，如图像的渲染。 一般的script标签（不带async等属性）加载时会阻塞浏览器，也就是说，浏览器在下载或执行该js代码块时，后面的标签不会被解析，例如在head中添加一个script，但这个script下载时网络不稳定，很长时间没有下载完成对应的js文件，那么浏览器此时一直等待这个js文件下载，此时页面不会被渲染，用户看到的就是白屏。 流览器之所以会采用同步模式，是因为加载的js文件中有对dom的操作，重定向，输出document等默认行为，所以同步才是最安全的。通常会把要加载的js放到body结束标签之前，使得js可在页面最后加载，尽量减少阻塞页面的渲染。这样可以先让页面显示出来。 异步加载 (async loading)常见异步加载举例：12345678(function() &#123;var s = document.createElement('script');s.type = 'text/javascript';s.async = true;s.src = 'http://XXX.com/script.js';var x = document.getElementsByTagName('script')[0]; x.parentNode.insertBefore(s, x);&#125;)(); 异步加载也叫非阻塞模式加载，浏览器在下载js的同时，同时还会执行后续的页面处理。在script标签内，用js创建一个script元素并插入到document中，这种就是异步加载js文件了。 同步加载流程是瀑布模型，异步加载流程是并发模型。 延迟加载 (lazy loading)有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。延迟加载就是一开始并不加载这些暂时不用的js，而是在需要的时候或稍后再通过js 的控制来异步加载。也就是将 js 切分成许多模块，页面初始化时只加载需要立即执行的 js ，然后其它 js 的加载延迟到第一次需要用到的时候再加载。特别是页面有大量不同的模块组成，很多可能暂时不用或根本就没用到。就像图片的延迟加载，在图片出现在可视区域内时（在滚动条下拉）才加载显示图片。 预加载预加载是一种浏览器机制，使用浏览器空闲时间来预先下载/加载用户接下来很可能会浏览的页面/资源，当用户访问某个预加载的链接时，如果从缓存命中,页面就得以快速呈现。 HTML页面加载和解析流程 用户输入网址访问静态的资源文件（假设是个html页面，并且是第一次访问，此时确保文件不是从缓存里取出），浏览器向服务器发出请求，服务器返回html文件。 浏览器开始载入html代码，发现标签内有一个标签引用外部CSS文件。 浏览器又发出CSS文件的请求，服务器返回这个CSS文件。 浏览器继续载入html中部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了。 浏览器在代码中发现一个标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码。 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码。 浏览器发现了一个包含一行JavaScript代码的标签，赶快运行它。 Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个（style.display=”none”）。 当遇到代码时，渲染结束。 加载方式123window.onload = function()&#123; // some code&#125; 这段代码会在 整个页面的document全部加载完成以后执行。不幸的这种方式不仅要求页面的DOM tree全部加载完成，而且要求所有的外部图片和资源全部加载完成。更不幸的是，如果外部资源，例如图片需要很长时间来加载，那么这个js效果就会让用户感觉失效了。 123$(document).ready(function()&#123; //some code&#125;) 简写形式： 123$(function()&#123; //some code&#125;) 就仅仅 只需要加载所有的DOM结构，在浏览器把所有的HTML放入DOM树之前就执行js效果。包括在加载外部图片和资源之前。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js加载方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flexbox弹性布局]]></title>
    <url>%2F2018%2F09%2F29%2Fflexbox%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[任何一个容器都可以指定 Flex 布局 123.box&#123; display: flex;&#125; 行内元素也可以使用 Flex 布局 123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器要加上 -webkit 前缀 1234.box&#123; display: -webkit-flex; display: flex;&#125; 设为 Flex 布局后，子项目的 float , clear 和 vertical-align 属性都将失效。 基本概念采用 Flex 布局的元素(display:flex)，称为 Flex 容器（flex container），它的所有子元素自动成为容器成员，称为子项目。 容器默认存在两根主轴: 水平的主轴(main axis) 和 垂直的交叉轴(cross axis)。 主轴的开始位置(与边框的交叉点)叫做 main start , 结束位置叫做 main end ;交叉轴的开始位置叫做 cross start , 结束位置叫做 cross end 。 项目默认沿着主轴排列,单个子项目占据的主轴空间叫做 main size ,占据的交叉轴空间叫做 cross size 。 Flex 容器的六个属性 flex-direction : row row-reverse column column-reverse flex-warp : nowrap wrap wrap-reverse flex-flow : &lt;flex-direction&gt; 和 &lt;flex-wrap&gt; justify-content : flex-start flex-end center space-beteen space-around align-items : flex-start flex-end center baseline stretch align-content : flex-start flex-end center space-beteen space-around stretch flex-direction 属性flex-direction 属性决定主轴的方向(即子项目的排列方向),它可能有4个值: row(默认值) : 主轴为水平方向，起点在左端。 row-reverse : 主轴为水平方向，起点在右端。 column : 主轴为垂直方向，起点在顶部(top)。 column-reverse : 主轴为垂直方向，起点在底部(bottom)。 flex-wrap 属性默认情况下，子项目都排在一条轴线上。 flex-wrap 属性定义了如果一条轴线排不下如何换行。 nowrap(默认值) : 不换行 wrap : 换行，第一行在上方 wrap-reverse : 换行，第一行在下方。如下图 flex-flow 属性flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap justify-content 属性justify-content 属性定义了子项目在主轴上的对齐方式，他可能取五个值，具体对齐方式与轴的方向有关，下面假设主轴从左到右。 flex-start(默认值) : 左对齐 flex-end : 右对齐 center : 居中 space-beteen : 两段对齐，子项目之间的间隔都相等 space-around : 每个子项目两侧的间隔相等。所以，子项目之间的间隔比项目与容器边框的间隔大一倍 align-items 属性align-items 属性定义子项目在交叉轴上如何对齐,默认情况下是垂直方向,从上到下。 flex-start : 交叉轴的起点对齐 flex-end : 交叉轴的终点对齐 center : 交叉轴的中点对齐 baseline : 项目的第一行文字的基线对齐 stretch(默认值) : 如果子项目未设置高或者设置为auto,将占满整个容器的高度 align-content 属性align-content 属性定义了多根轴线的对齐方式，如果项目只有一根轴线，该属性不起作用。 flex-start : 与交叉轴的起点对齐 flex-end : 与交叉轴的终点对齐 center : 与交叉轴的终点对齐 space-beteen : 与交叉轴两端对齐，轴线之间的间隔平均分布 space-around : 每根轴线两侧的间隔都相等，所以，轴线之间的间隔比轴线与容器边框的间隔大一倍 Flex 子项目的6个属性 order : &lt;integer&gt; (整数) flex-grow : &lt;number&gt; (正整数) flex-shrink : &lt;number&gt;(正整数) flex-basis : &lt;length&gt; (子项目固定长度或者auto) flex : 是 flex-grow flex-shrink flex-basis 的简写,默认值为 0 1 auto ,后两个属性可选 align-self : auto flex-start flex-end center baseline stretch order 属性order 属性定义子项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow 属性flex-grow 属性定义项目的放大比例，默认值为0，即存在剩余空间也不放大。 如果所有的子项目 flex-grow 属性都为1，存在剩余空间则它们将等分剩余空间，如果一个子项目的 flex-grow 属性为2，其他子项目都为1，则前者占据的剩余空间将比其他子项目多一倍，如下图。 flex-shrink 属性flex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有子项目的 flex-shrink 属性都为1，当空间不足时，都将等比例缩小，如果一个子项目的 flex-shrink 属性为0，其他子项目都为1，则空间不足时，前者不缩小，如下图。 flex-basis 属性flex-basis 属性定义了在分配多余空间之前，子项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto ，即子项目的本来大小。 它可以设为跟 width 或 height 属性一样的值(比如100px)，则项目将占据固定空间。 flex-basis 取值情况: auto :首选检索该子项目的主尺寸（是否设置了width），如果 width 不等于 auto,则使用值 width 的值。如果也是 auto，则使用值为 content 的大小。 content :指根据该子项目的内容自动布局。有的用户代理没有实现取 content的值，等效的替代方案是 flex-basis 和 width 都取 auto 。 百分比:根据其包含块(即伸缩父容器)的 width 计算。如果包含块的 width 未定义(即父容器的主尺寸取决于子元素)，则计算结果和设为 auto 一样。 举一个例子： 1234567891011121314151617181920212223242526272829&lt;div class="parent"&gt; &lt;div class="item-1"&gt;&lt;/div&gt; &lt;div class="item-2"&gt;&lt;/div&gt; &lt;div class="item-3"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style type="text/css"&gt; .parent &#123; display: flex; width: 600px; &#125; .parent &gt; div &#123; height: 100px; &#125; .item-1 &#123; width: 140px; flex: 2 1 0%; background: blue; &#125; .item-2 &#123; width: 100px; flex: 2 1 auto; background: darkblue; &#125; .item-3 &#123; flex: 1 1 200px; background: lightblue; &#125;&lt;/style&gt; 主轴上父容器的总尺寸为600px 子元素的总基准值是:0% + auto + 200px = 300px,其中 0% 即 0 auto 对应取 width=100px 故剩余空间为: 600px - 300px = 300px 伸缩放大系数之和为: 2+2+1=5 剩余空间分配如下 item-1 和 item-2 各分配 2/5,各得 120px item-3 分配 1/5,得60px 各项目最终的宽度为: item-1 = 0% + 120px = 120px item-2 = auto +120px =220px item-3 = 200px + 60px = 260px 当 item-1 基准值取 0% 的时候，是把该项目视为零尺寸的，故即便声明其尺寸为 140px，也并没有什么用，形同虚设 而 item-2 基准值取 auto 的时候，根据规则基准值使用值是主尺寸值即 100px，故这 100px 不会纳入剩余空间. flex 属性flex 属性是 flex-grow flex-shrink flex-basis 的简写，默认值为 0 1 auto ,后两个属性可选。 该属性的快捷键说明： flex:auto 等价于 flex:1 1 auto flex:none 等价于 flex:0 0 auto flex:1 等价于 flex:1 1 0% flex:0% 等价于 flex:1 1 0% flex:24px 等价于 flex:1 1 24px flex:2 3 等价于 flex:2 3 0% flex:2 23px 等价于 flex:2 1 23px 建议优先使用这个属性，而不是单独写三个分离属性，因为浏览器会推算相关值。 align-self 属性align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto ，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch 。 —摘自阮一峰的个人博客]]></content>
      <tags>
        <tag>flex</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式设计]]></title>
    <url>%2F2018%2F09%2F27%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[为何移动设备优先？移动优先当代响应式设计的最佳流程：在制作响应式网站的时候，先搞定手机版，然后再去为更大设备去设计和开发。无论从界面设计还是代码执行效率的角度而言，移动优先都有明显优势。 由简入繁 定制自己的色盘 Material Design Color Palette 选择两种颜色，第一种为主色，第二种为强调色。然后下载 SASS版本。 色盘上各颜色的作用: primary color:主色,一般和白色和灰色混用，来显示页面的主体背景.他和白色灰色加起来要占到页面百分之八九十的面积。 accent color:强调色,来强调最重要的一些按钮或者是表单的位置，来突出显示。 text/icons:字体和图片颜色。 primary text:主要的字体颜色。 secondary text:从属内容字体颜色。 divider color:分割线的颜色。 dark primary color 和 light primary color:深主色和浅主色 什么是响应式？简单定义 一份代码能够适应全部屏幕尺寸 响应式的三要素 弹性布局 弹性图片 media 查询 四中常见的响应式模式Column Drop列下沉手机上每一个大块单独占据一行，随着屏幕尺寸拉伸会在同一行上形成多个 column 列 Mostly Fuild基本上跟 Column Drop 一样，但是有一点点“固定布局“的特点：当到达一定宽度后，主体内容部分不再变宽，成为固定宽度。 Layout Shifter变换式，也就是不必遵循原有内容顺序，可以根据最佳展示需要来调整大块顺序。 Off Canvas抽屉式，屏幕不够宽的时候，隐藏，通过按钮呼出。足够宽的屏幕上，始终显示。 viewport 设置问题是什么？手机上任何设备都按照 960 的宽度来显示，造成很多设备上字体变成了原来的 1/3 。 解决方案1&lt;meta name="viewport" content="width=device-width"&gt; viewport 就是浏览器窗口。这个设置翻译成大白话就是：浏览器呀，你就按照你的自然宽度来来给我显示网站就行了，不要自作聪明。 这样就解决了上面所说的问题了。意思是把我的视窗 viewport 的宽度，设置为设备的实际宽度，比如说前面提到的 iphone5 ，本来默认视窗宽度是 960px ，那么有了这一行设置之后，视窗宽度就变成了设备实际宽度了 320px 。这样后面再来显示页面元素，当然就不会缩小了。 更为常见的设置: 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; 设备在水平放置的时候（手机横屏），字体会无缘无故的变的很大，所以需要加上 initial-scale=1.0 (初始化缩放等于1) 这个设置。 像素尺寸iphone5 对外宣传像素 640*1136像素 是物理像素，而我们实际开发中px是逻辑像素，两则之间的关系是不一样的。 px: css pixels 逻辑像素，浏览器使用的抽象单位。 可以根据不同的设备来变大变小。 dp,pt: device independent pixels 设备无关像素 物理像素的大小是固定的 dpr: devicePixelRatio 设备像素缩放比 来控制px 与 dp pt 之间的关系，计算公式 1px = dpr2 * dp 为什么iphone5是320px*568px? ==&gt; 因为 dpr = 2 平面上:1px = (2)2 * dp 也就是1个css像素等于4个物理像素，如上图。 纬度上:1px = 2 * dp 因此: 640dp1136dp ==&gt; 320px568px 为什么iphone5 的dpr为2？ DPI:打印机每英寸可以喷的墨汁点（印刷行业） PPI:屏幕每英寸的像素数量，即单位英寸内的像素密度 目前，在计算机显示设备参数描述上，二者意思表达的是一样的。 计算公式 :以 iphone5 为例子 ppi= &radic;(11362dp + 6402dp) / 4 = 326ppi (视网膜Retina屏) PPI越高，像素越高，图像越清晰，但可视度越低，系统默认设置缩放比越大 Retina 屏（高清屏）:dpr都是大于等于2 整个换算流程以 iphone5 为例子 : 设备分辨率 1136*640 dp ==&gt; &radic;(11362dp + 6402dp) / 4 = 326ppi ==&gt; 326 ppi属于 retina屏幕, dpr=2 ==&gt; 1px = dpr2 * dp ==&gt; iphone5 的屏幕为 320 * 568 px]]></content>
      <categories>
        <category>布局</category>
      </categories>
      <tags>
        <tag>响应式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoDB如何搭建数据库]]></title>
    <url>%2F2018%2F09%2F27%2FmongoDB%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[MongoDB 基本概念 MongoDB 的官网 MongoDB 中文社区 MongoDB 中文网 MongoDB：是一个数据库软件，有时候我们简称它叫一个数据库，但是其实一个 MongoDB 运行起来 可以里面同时运行多个数据库 Database: 数据库。一般做法是，一个项目对应一个数据库。 Collection: 集合。类似于关系型数据库下的表的概念，例如全班同学信息。 Document：文档。一个集合中会包含多个文档（一个文档中存储一个同学的信息）。文档对应关系型数据库中的 记录 这个概念。 安装1brew install mongodb 查看安装目录1which mongod MongoDB启动与使用启动12mkdir -p data/dbmongod --dbpath=./data/db 123brew services start mongodb//使用homeBrew安装的 启动命令. brew services stop mongodb 一般在项目文件夹主目录建立一个 data/db 文件夹来当做数据库地址。mkdir -p 创建一个目录的时候，若其父目录不存在，则自动创建，而不是默认的报错,例如： mkdir /home/a/b 若/home目录下不存在a目录，则会报错。加上-p选项后，就会先建立a目录，然后在a目录下再建立b目录。 注意：--dbpath后的值表示数据库文件的存储路径,而且后面的路径必须事先创建好，必须已经 存在 ，否则服务开启失败。 注意：这个命令窗体绝对不能关,关闭这个窗口就相当于停止了mongodb服务 也可以在命令后面加上参数 --port 27017 来指定端口 一直处于运行状态，说明 MongoDB 数据库可以使用了。查看 mongod 命令的帮助文档，可以在命令行中输入命令 mongod -h 使用既然 MongoDB 已经启动了，那如何操作它呢？通过 MongoDB 提供的 mongo shell 工具，可以很方便的和 MongoDB 数据库进行通信，也可以使用图形化的界面。 使用 mongo shell 工具操作数据库首先要确保在MongoDB 数据库运行的状态下，才能启动 mongo shell，在命令行中输入: 1mongo 切换到 mongo shell 运行环境，在这里可以调用 MongoDB 提供的接口操作数据库中存储的数据 show dbs 查看所有的数据库名称 db 或 db.getName() 查看当前使用的数据库,db代表的是当前数据库。 use react-express-api 创建新的数据库 react-express-api,但是react-express-api数据库并不存在，只有当数据存入数据库时候才会真正的创建数据库,如果此数据库存在，则切换到此数据库下。 db.createCollection(&#39;posts&#39;) 在数据库中创建一个新的 collection,例子中的是 posts 集合。 往posts 集合存入数据 1db.posts.insert(&#123;category: 'db', title: 'learning mongodb', content: 'mongodb is a nosql database'&#125;) db.posts.find() 查找 posts 集合中的所有记录 更新 posts 集合中的一条记录 1db.posts.update(&#123;_id: ObjectId(&apos;xxx&apos;)&#125;, &#123;$set: &#123;title: &apos;mongodb&apos;&#125;&#125;) db.posts.remove({_id: ObjectId(&#39;xxx&#39;)}) 删除 posts 集合中的一条记录 db.posts.remove({}) 删除 posts 集合中的所有记录 删除数据库 react-express-api 12use react-express-apidb.dropDatabase() 使用图形化界面 是一个用 express 技术开发的，MongoDB 的 GUI (图形界面)。可以方便美观的 操作 MongoDB 中的数据。 参考：http://haoqicat.com/hand-in-hand-react/4-mongo-express 1npm install -g mongo-express mongo-express 装好之后，我们需要通知它到底要连接到哪个数据库，通过修改 mongo-express 的配置文件来搞定。 首先下面的这个命令可以帮我们找到 mongo-express 的安装位置： 12$ npm list -g mongo-express/Users/wenxiangye/.nvm/versions/node/v7.4.0/lib 找到后就可以进入安装文件夹来修改配置文件了。 1234cd /Users/wenxiangye/.nvm/versions/node/v7.4.0/libcd node_modulescd mongo-expresscp config.default.js config.js 最后一步，就是把示例配置文件 config.defualt.js（这个名字程序是不会读的） ，改名为真实的配置文件 config.js , 也就是说是程序会自动读到的配置文件。打开配置文件，把 1234567mongo = &#123; db: 'db', username: 'admin', password: 'pass', ... url: 'mongodb://localhost:27017/db',&#125;; 改为 1234567mongo = &#123; db: 'digicity', username: '', password: '', ... url: 'mongodb://localhost:27017/digicity',&#125;; 上面的 digicity 就是我们要操作的数据库的名字，这个是通过 mongo shell 中，执行 show dbs 看到的。由于我们的 digicity 这个数据库本身没有设置密码，所以上面 username 和 password 两项都改成空字符串就可以了。同时，mongo-express 这个软件自己还有自己登陆的用户名和密码，并且有默认值，通过 config.js 中这几行： 1234basicAuth: &#123; username: process.env.ME_CONFIG_BASICAUTH_USERNAME || 'admin', password: process.env.ME_CONFIG_BASICAUTH_PASSWORD || 'pass',&#125;, 默认的用户名是 admin ，密码是 pass 。在命令行中启动 mongo-express 1$ mongo-express 浏览器中打开 http://localhost:8081 可以开始使用 mongo-express 了。]]></content>
      <categories>
        <category>mongoDB</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react路由]]></title>
    <url>%2F2018%2F09%2F27%2Freact%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[基本用法使用时首先需要安装 react-router 这个包，Router 组件本身只是一个容器，真正的路由则需要通过 Route 组件定义。 1234567import &#123; Router, Route, hashHistory &#125; from 'react-router';render(( &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path="/" component=&#123;App&#125;/&gt; &lt;/Router&gt;), document.getElementById('app')); 访问 / (例如 localhost:8080/),组件 App 就会加载到 document.getElementById(&#39;app&#39;) 这个节点上。当设置 history:{hashHistory} 时，路由的切换由 URL的hash变化决定的，即URL的 # 部分发生变化，举个例子:访问 localhost:8080 时，实际会看到的是 localhost:8080/#/. Route组件定义了URL路径与组件的对应关系，可以同时使用多个 Route 组件12345&lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path="/" component=&#123;App&#125;/&gt; &lt;Route path="/repos" component=&#123;Repos&#125;/&gt; &lt;Route path="/about" component=&#123;About&#125;/&gt;&lt;/Router&gt; 上面代码中，用户访问 /repos（比如 http://localhost:8080/#/repos）时，加载 Repos 组件；访问 /about（http://localhost:8080/#/about）时，加载 About 组件。 路由的嵌套Route 组件还可以嵌套。 123456&lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path="/" component=&#123;App&#125;&gt; &lt;Route path="/repos" component=&#123;Repos&#125;/&gt; &lt;Route path="/about" component=&#123;About&#125;/&gt; &lt;/Route&gt;&lt;/Router&gt; 上面的嵌套 ,当用户访问 /repos 时，会首先加载 App 组件然后在它的内部再加载 Repos组件，实际上就变成了下面这种关系. 123&lt;App&gt; &lt;Repos/&gt;&lt;/App&gt; 需要注意的是 App 组件需要写成下面的样子 1234567export default React.createClass(&#123; render() &#123; return &lt;div&gt; &#123;this.props.children&#125; &lt;/div&gt; &#125;&#125;) 上面的代码， App 组件的 this.props.children 属性就代表子组件，正常的组件嵌套不也是需要这样定义吗，这样就比较好理解了。 另一种定义嵌套路由的方式可以不写在 Router 组件里面，单独传入 Router 组件的 router 属性 123456let routes = &lt;Route path="/" component=&#123;App&#125;&gt; &lt;Route path="/repos" component=&#123;Repos&#125;/&gt; &lt;Route path="/about" component=&#123;About&#125;/&gt; &lt;/Route&gt;;&lt;Router routes=&#123;routes&#125; history=&#123;browserHistory&#125;/&gt; path属性Route 组件的 path 属性指定路由的匹配规则，这个属性是可以省略的，但是只能是父级省略(父级省不省略都会加载父级，没什么意义)。同级省略也不会加载。 123456&lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path="/" component=&#123;Home&#125;&gt; &lt;Route path="/about" component=&#123;About&#125; /&gt; &lt;Route path="/blog" component=&#123;Blog&#125; /&gt; &lt;/Route&gt;&lt;/Router&gt; 父级省略了 path=&quot;/&quot; 效果一样，访问/about路由时，父级同样会加载，但是如果 path=&quot;/blog&quot; 省略，当访问 /时 ，Blog组件不会加载。 path 属性可以使用通配符 :name 匹配URL的一个部分，直到遇到 / ? # 为止，这个路径参数可以通过 this.props.params.name 取出，举个例子 1234567891011121314151617181920212223242526272829&lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path="/" component=&#123;Home&#125;&gt; &lt;Route path="/about" component=&#123;About&#125; /&gt; &lt;Route path="/blog/:name" component=&#123;Blog&#125; /&gt; &lt;/Route&gt;&lt;/Router&gt;//Home.jsrender()&#123; return( &lt;div style=&#123;&#123;border:"5px solid green"&#125;&#125;&gt; &lt;ul role="nav"&gt; &lt;li&gt;&lt;Link to="/about"&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/blog/yewenxiang"&gt;Blog&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; 我是Home组件. &#123;this.props.children&#125; &lt;/div&gt; )&#125;//Blog.jsrender()&#123; return( &lt;div style=&#123;&#123;border:"5px solid red"&#125;&#125;&gt; 我是Blog组件. &lt;h3&gt;&#123;this.props.params.name&#125;&lt;/h3&gt; &lt;/div&gt; )&#125; 这样在 Blog组件中就可以通过 this.props.params.name 拿到 yewenxiang 这个值了。在 Router 定义的是匹配的规则，在 Link 中定义的就是传入 Blog组件的值了。 () 表示URL的这个部分是可选的 123&lt;Route path=&quot;/hello(/:name)&quot;&gt;// 匹配 /hello// 匹配 /hello/yewenxiang *匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。 12345678&lt;Route path=&quot;/files/*&quot;&gt;// 匹配 /files/// 匹配 /files/a// 匹配 /files/a/b&lt;Route path=&quot;/files/*.*&quot;&gt;// 匹配 /files/hello.jpg// 匹配 /files/hello.html ** 匹配任意字符，直到下一个/、?、# 为止。匹配方式是贪婪模式。 123&lt;Route path=&quot;/**/*.jpg&quot;&gt;// 匹配 /files/hello.jpg// 匹配 /files/path/to/file.jpg 什么是正则表达式的贪婪与非贪婪匹配 贪婪匹配:正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。 非贪婪匹配：就是匹配到结果就好。 路由的匹配规则 path属性也可以使用相对路径（不以/开头），匹配时就会相对于父组件的路径。 路由匹配规则是从上到下执行，一旦发现匹配，就不再其余的规则了。 1234&lt;Router&gt; &lt;Route path="/:userName/:id" component=&#123;UserPage&#125;/&gt; &lt;Route path="/about/me" component=&#123;About&#125;/&gt;&lt;/Router&gt; 上面代码中，用户访问/about/me时，不会触发第二个路由规则，因为它会匹配/:userName/:id这个规则。因此，带参数的路径一般要写在路由规则的底部。 IndexRoute 指定根路由的默认子组件123456&lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path="/" component=&#123;Home&#125;&gt; &lt;Route path="/about" component=&#123;About&#125; /&gt; &lt;Route path="/blog/:name" component=&#123;Blog&#125; /&gt; &lt;/Route&gt;&lt;/Router&gt; 上面的代码，当访问根路径 / 时候没有加载任何的子组件，这是正常的现象，但是如果我们需要访问 / 加载一个默认的组件如何去解决呢。IndexRoute 就是来解决这个问题的。 12345678910&lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path="/" component=&#123;Home&#125;&gt; &lt;IndexRoute component=&#123;In&#125; /&gt; &lt;Route path="/about" component=&#123;About&#125; /&gt; &lt;Route path="/blog/:name" component=&#123;Blog&#125; /&gt; &lt;/Route&gt;&lt;/Router&gt;// Home.js&#123;this.props.children || &lt;In /&gt;&#125; 这样定义后，当访问 /(根路由),时就会默认加载 In 这个组件了,加载的组件结构如下: 123&lt;Home&gt; &lt;In /&gt;&lt;/Home&gt; 可以把IndexRoute想象成某个路径的index.html。这种组件结构就很清晰了：Home只包含下级组件的共有元素，本身的展示内容则由In组件定义。这样有利于代码分离，也有利于使用React Router提供的各种API。 路由嵌套和组件嵌套的一个误区123456&lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path="/" component=&#123;Home&#125;&gt; &lt;Route path="/about" component=&#123;About&#125; /&gt; &lt;Route path="/blog/:name" component=&#123;Blog&#125; /&gt; &lt;/Route&gt;&lt;/Router&gt; 我在 Home 组件中定义了 {this.props.children},访问 / 时，以为 About 和 Blog组件也会显示，其实不会，拿上面的代码来说。 / 只会加载 Home组件，而不会加载 About,Blog。结构如下 12&lt;Home&gt;&lt;/Home&gt; 我错误的想成了 12345//这是我错误的想法&lt;Home&gt; &lt;About /&gt; &lt;Blog /&gt;&lt;/Home&gt; Redirect 路由的跳转组件&lt;Redirect&gt;组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由。 1234567891011&lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path="/" component=&#123;Home&#125;&gt; &lt;IndexRoute component=&#123;In&#125; /&gt; &lt;Route path="/about" component=&#123;About&#125;&gt; &lt;Route path="/me" component=&#123;Me&#125;&gt; &lt;Redirect from="/messages" to="/about" /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;Route path="/blog/:name" component=&#123;Blog&#125; /&gt; &lt;/Route&gt;&lt;/Router&gt; 访问 /messages 时会跳转到 /about,结构如下 123&lt;Home&gt; &lt;About /&gt;&lt;/Home&gt; 注意 &lt;IndexRoute component={In} /&gt; 这个组件没加载,只有访问 /时会加载。 IndexRedirect 组件用于访问根路由的时候，将用户重定向到某个子组件。 12345678910&lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path="/" component=&#123;Home&#125;&gt; &lt;IndexRedirect to="/me" /&gt; &lt;Route path="/about" component=&#123;About&#125;&gt; &lt;Route path="/me" component=&#123;Me&#125;&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;Route path="/blog/:name" component=&#123;Blog&#125; /&gt; &lt;/Route&gt;&lt;/Router&gt; 上面的代码中，用户访问/根目录时，将重定向到子组件 /me，重定向后页面中渲染的组件结构如下: 12345&lt;Home&gt; &lt;About&gt; &lt;Me /&gt; &lt;/About&gt;&lt;/Home&gt; LinkLink组件用于取代&lt;a&gt;元素，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是&lt;a&gt;元素的React 版本，可以接收Router的状态。 12345678render() &#123; return &lt;div&gt; &lt;ul role="nav"&gt; &lt;li&gt;&lt;Link to="/about"&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to="/repos"&gt;Repos&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&#125; 如果需要当前的路由链接与其他路由链接有不同的样式，来突出当前的位置，可以使用 Link 组件的 activeStyle 属性 12&lt;Link to=&quot;/about&quot; activeStyle=&#123;&#123;color: &apos;red&apos;&#125;&#125;&gt;About&lt;/Link&gt;&lt;Link to=&quot;/repos&quot; activeStyle=&#123;&#123;color: &apos;red&apos;&#125;&#125;&gt;Repos&lt;/Link&gt; 上面的代码，当前的链接会显示红色，这种定义方法可以想象成HTML里面定义行内的样式，另外一种更好的方式是，使用activeClassName 指定当前路由链接的 Class，也就是当前页面的路由链接才会添加上这个类，可以想象成外联样式。 12&lt;Link to=&quot;/about&quot; activeClassName=&quot;active&quot;&gt;About&lt;/Link&gt;&lt;Link to=&quot;/repos&quot; activeClassName=&quot;active&quot;&gt;Repos&lt;/Link&gt; 在Router组件之外，导航到路由页面，可以使用浏览器的History API，像下面这样写。12import &#123; browserHistory &#125; from &apos;react-router&apos;;browserHistory.push(&apos;/some/path&apos;); IndexLink如果链接到根路由/，不要使用Link组件，而要使用IndexLink组件。这是因为对于根路由来说，activeStyle和activeClassName会失效，或者说总是生效一直会显示样式，因为/会匹配任何子路由。而IndexLink组件会使用路径的精确匹配。 1&lt;IndexLink to=&quot;/&quot; activeClassName=&quot;active&quot;&gt;Home&lt;/IndexLink&gt; 另一种方式使用Link组件的onlyActiveOnIndex属性，也能达到同样效果。 1&lt;Link to=&quot;/&quot; activeClassName=&quot;active&quot; onlyActiveOnIndex=&#123;true&#125;&gt;Home&lt;/Link&gt; 实际上，IndexLink就是对Link组件的onlyActiveOnIndex属性的包装。 histroy 属性Router组件的history属性，用来监听浏览器地址栏的变化，并将URL解析成一个地址对象，供 React Router 匹配。history属性，一共可以设置三种值: browserHistory 路由将通过URL的hash部分（#）切换，URL的形式类似example.com/#/some/path。 hashHistory 浏览器的路由就不再通过Hash完成了，而显示正常的路径example.com/some/path，背后调用的是浏览器的History API。但是，这种情况需要对服务器改造。否则用户直接向服务器请求某个子路由，会显示网页找不到的404错误。如果开发服务器使用的是webpack-dev-server，加上–history-api-fallback参数就可以了。 createMemoryHistory 主要用于服务器渲染。它创建一个内存中的history对象，不与浏览器URL互动。const history = createMemoryHistory(location) 官方文档 表单处理Link组件用于正常的用户点击跳转，但是有时还需要表单跳转、点击按钮跳转等操作。这些情况怎么跟React Router对接呢？下面是一个表单。 12345&lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type="text" placeholder="userName"/&gt; &lt;input type="text" placeholder="repo"/&gt; &lt;button type="submit"&gt;Go&lt;/button&gt;&lt;/form&gt; 第一种方法是使用browserHistory.push 12345678910import &#123; browserHistory &#125; from 'react-router'// ... handleSubmit(event) &#123; event.preventDefault() const userName = event.target.elements[0].value const repo = event.target.elements[1].value const path = `/repos/$&#123;userName&#125;/$&#123;repo&#125;` browserHistory.push(path) &#125;, 第二种方法是使用context对象 123456789101112export default React.createClass(&#123; // ask for `router` from context contextTypes: &#123; router: React.PropTypes.object &#125;, handleSubmit(event) &#123; // ... this.context.router.push(path) &#125;,&#125;) 路由的钩子每个路由都有Enter和Leave钩子，用户进入或离开该路由时触发。 1234&lt;Route path="about" component=&#123;About&#125; /&gt;＜Route path="inbox" component=&#123;Inbox&#125;&gt; ＜Redirect from="messages/:id" to="/messages/:id" /&gt;&lt;/Route&gt; 上面的代码中，如果用户离开/messages/:id，进入/about时，会依次触发以下的钩子。 123/messages/:id 的 onLeave/inbox 的 onLeave/about 的 onEnter 下面是一个例子，使用onEnter钩子替代&lt;Redirect&gt;组件。 12345678&lt;Route path="inbox" component=&#123;Inbox&#125;&gt; &lt;Route path="messages/:id" onEnter=&#123; (&#123;params&#125;, replace) =&gt; replace(`/messages/$&#123;params.id&#125;`) &#125; /&gt;&lt;/Route&gt; onEnter钩子还可以用来做认证。 1234567891011const requireAuth = (nextState, replace) =&gt; &#123; if (!auth.isAdmin()) &#123; // Redirect to Home page if not an Admin replace(&#123; pathname: '/' &#125;) &#125;&#125;export const AdminRoutes = () =&gt; &#123; return ( &lt;Route path="/admin" component=&#123;Admin&#125; onEnter=&#123;requireAuth&#125; /&gt; )&#125; 下面是一个高级应用，当用户离开一个路径的时候，跳出一个提示框，要求用户确认是否离开。 1234567891011121314151617const Home = withRouter( React.createClass(&#123; componentDidMount() &#123; this.props.router.setRouteLeaveHook( this.props.route, this.routerWillLeave ) &#125;, routerWillLeave(nextLocation) &#123; // 返回 false 会继续停留当前页面， // 否则，返回一个字符串，会显示给用户，让其自己决定 if (!this.state.isSaved) return '确认要离开？'; &#125;, &#125;)) 上面代码中，setRouteLeaveHook方法为Leave钩子指定routerWillLeave函数。该方法如果返回false，将阻止路由的切换，否则就返回一个字符串，提示用户决定是否要切换。 –整理自阮一峰的博客 –官方demo]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react表单]]></title>
    <url>%2F2018%2F09%2F27%2Freact%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[表单表单不同于其他 HTML 元素，因为它要响应用户的交互，显示不同的状态，所以在 React 里面会有点特殊。 状态属性表单元素有这么几种状态属性： value 对应 &lt;input&gt; 和 &lt;textarea&gt; checked 对应 checkbox 和 radio 的 &lt;input&gt; 所有 selected 对应 &lt;option&gt; 所有 在 HTML 中 &lt;textarea&gt; 的值可以由子节点（文本）赋值，但是在 React 中，要用 value 来设置。表单元素包含以上任意一种状态属性都支持 onChange 事件监听状态值的更改。针对这些状态属性不同的处理策略，表单元素在 React 里面有两种表现形式。 受控组件设置了 value 的&lt;input&gt; 是一个受限组件。 对于受限的 &lt;input&gt;，渲染出来的 HTML 元素始终保持 value 属性的值。例如： 123render: function() &#123; return &lt;input type="text" value="Hello!" /&gt;;&#125; 上面的代码将渲染出一个值为 Hello! 的 input 元素。用户在渲染出来的元素里输入任何值都不起作用，因为 React 已经赋值为 Hello!。如果想响应更新用户输入的值，就得使用 onChange 事件： 1234567891011121314151617181920212223class From extends React.Component&#123; constructor()&#123; super(); this.state = &#123; inputValue:"" &#125; &#125; handle(e) &#123; e.preventDefault(); this.refs.form.reset(); //点击提交按钮也会被重置表单 &#125; render()&#123; return ( &lt;div id="text"&gt; &lt;form action="" method="GET" onSubmit=&#123;this.handle.bind(this)&#125; ref="form" id="ye"&gt; &lt;input type="text" value=&#123;this.state.inputValue&#125; onChange=&#123;(event)=&gt; this.setState(&#123;inputValue:event.target.inputValue&#125;)&#125;&gt; &lt;/input&gt; &lt;/form&gt; &lt;/div&gt; ) &#125;&#125; React 将用户输入的值更新到 &lt;input&gt; 组件的 value 属性,这样页面会重新被渲染显示出输入的值。 非受控组件没有设置 value(或者设为 null) 的 &lt;input&gt; 组件是一个不受限组件，对于不受限的 &lt;input&gt; 组件，渲染出来的元素直接反应用户输入 123render: function() &#123; return &lt;input type="text" /&gt;; &#125; 上面的代码将渲染出一个空值的输入框，用户输入将立即反应到元素上。和受限元素一样，使用 onChange 事件可以监听值的变化。如果想给组件设置一个非空的初始值，可以使用 defaultValue 属性。例如： 123ender: function() &#123; return &lt;input type=&quot;text&quot; defaultValue=&quot;Hello!&quot; /&gt;; &#125; 上面的代码渲染出来的元素和受限组件一样有一个初始值，但这个值用户可以改变并会反应到界面上。 radio 、 checkbox 的 &lt;input&gt; 支持 defaultChecked属性 &lt;select&gt; 支持 defaultValue 属性 123456789101112131415161718192021222324252627282930313233343536class Form extends React.Component &#123; constructor() &#123; super(); this.state = &#123; inputValue: "", textareaValue: "我是文本域", selectValue:"", radio:"woman" &#125; &#125; handle(e) &#123; e.preventDefault(); this.refs.form.reset(); &#125; render() &#123; return ( &lt;div id="text"&gt; &lt;form action="" method="GET" onSubmit=&#123;this.handle.bind(this)&#125; ref="form"&gt; &lt;input type="text" value=&#123;this.state.inputValue&#125; onChange=&#123;(e)=&gt; this.setState(&#123;inputValue:e.target.value&#125;)&#125;&gt;&lt;/input&gt; &lt;textarea value=&#123;this.state.textareaValue&#125; onChange=&#123;(e)=&gt; this.setState(&#123;textareaValue:e.target.value&#125;)&#125;/&gt; &lt;input type="radio" value="man" name="sex1" defaultChecked/&gt;男 &lt;input type="radio" value="woman" name="sex2" checked=&#123;this.state.radio==="woman"&#125; onChange=&#123;(e)=&gt; this.setState(&#123;radio:e.target.value&#125;)&#125;/&gt;女 &lt;button type="submit"&gt;提交&lt;/button&gt; &lt;button type="reset"&gt;重置&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; ) &#125;&#125; 为什么使用受控组件？1&lt;input type="text" name="" value="ye" /&gt; 在React中使用表单组件时。上面的代码在HTML 中将渲染初始值为 ye 的输入框。用户改变输入框的值时，节点的 value 属性（property）将随之变化，但是 node.getAttribute(&#39;value&#39;) 还是会返回初始设置的值 ye,与 HTML 不同，React 组件必须在任何时间点描绘视图的状态，而不仅仅是在初始化时。 为什么 &lt;textarea&gt; 使用value 属性？在 HTML 中， &lt;textarea&gt;的值通常使用子节点设置： 12&lt;!-- 反例：在 React 中不要这样使用！ --&gt; &lt;textarea name="description"&gt;This is the description.&lt;/textarea&gt; 对 HTML 而言，让开发者设置多行的值很容易。但是，React 是 JavaScript，没有字符限制，可以使用 \n 实现换行。简言之，React 已经有 value、defaultValue 属性， 组件的子节点扮演什么角色就有点模棱两可了。基于此， 设置 &lt;textarea&gt; 值时不应该使用子节点： 1&lt;textarea name=&quot;description&quot; value=&quot;This is a description.&quot; /&gt; 为什么 &lt;select&gt; 使用 value 属性HTML 中 &lt;select&gt; 通常使用 &lt;option&gt; 的 selected 属性设置选中状态；React 为了更方面的控制组件，采用以下方式代替： 12345678&lt;select onChange=&#123;(e)=&gt;&#123; this.setState(&#123;selectValue: e.target.value&#125;);&#125;&#125; defaultValue="2"&gt; &lt;option value="1"&gt;1&lt;/option&gt; &lt;option value="2"&gt;2&lt;/option&gt; &lt;option value="3"&gt;3&lt;/option&gt; &lt;option value="4"&gt;4&lt;/option&gt;&lt;/select&gt; 注意：给 value 属性传递一个数组，可以选中多个选项：&lt;select multiple={true} value={[&#39;B&#39;, &#39;C&#39;]}&gt;。 复选框如何实现受控组件？12345678910111213141516171819202122232425262728293031class Form extends React.Component &#123; constructor() &#123; super(); this.state = &#123; checkboxValue:["apple"] &#125; &#125; handleCheckbox(e)&#123; let ckValue = this.state.checkboxValue; let clickValue = e.target.value; let index = ckValue.findIndex(num=&gt;num===clickValue); // 或者使用 indexOf() // let index = ckValue.indexOf(clickValue ); if(index === -1)&#123; ckValue.push(clickValue); &#125;else&#123; ckValue.splice(index,1); &#125; this.setState(&#123;checkboxValue:ckValue&#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;input type="checkbox" value="apple" name="fruits" onChange=&#123;this.handleCheckbox.bind(this)&#125; defaultChecked/&gt;苹果 &lt;input type="checkbox" value="banana" name="fruits" onChange=&#123;this.handleCheckbox.bind(this)&#125;/&gt;香蕉 &lt;input type="checkbox" value="pear" name="fruits" onChange=&#123;this.handleCheckbox.bind(this)&#125;/&gt;梨子 &lt;/div&gt; ) &#125;&#125; 总结 表单定义 value 属性和值之后，用户无法在表单输入值或者点击 radio 。 受控组件 定义了 onchange() 方法，value的值交给state来控制。 非受空组件 定义了 defaultValue 不受state管理数据 不能跟新value的值，但是用户可以在表单中输入数据。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ref如何去使用]]></title>
    <url>%2F2018%2F09%2F27%2Fref%E5%A6%82%E4%BD%95%E5%8E%BB%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[ref的作用获取DOM后可以方便结合现有非 react 类库的使用，通过 ref/refs 可以取得组件实例，进而取得原生节点，不过尽量通过 state/props 更新组件，不要使用该功能去更新组件的DOM 用来调用子组件里面的方法。 用来获取页面的节点 ref的使用方式三种方法都可以获取DOM ReactDOM.findDOMNode(this.refs.xxx); this.refs.xxx(官方不推荐) 1234567891011121314151617181920212223import React from "react";import ReactDOM from "react-dom";class HandleDOMComponent extends React.Component &#123; componentDidMount()&#123; // 两种方式都可以获取到元素 let ele = ReactDOM.findDOMNode(this.refs.content); let ele2 = this.refs.content; // 如果想用 jquery，那么这是个好时机 console.log( ele ); console.log( ele.innerHTML ); console.log( ele2.innerHTML ); &#125; render()&#123; return ( &lt;div&gt; &lt;div ref='content'&gt;这是我DOM元素里面的内容&lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default HandleDOMComponent; 另外一种官方推荐的方式： 123456789101112class App extends React.Component&#123; componentDidMount()&#123; console.log(this.newAttr); &#125; render()&#123; return ( &lt;div&gt; &lt;div ref=&#123;(jiedian)=&gt;this.newAttr=jiedian&#125;&gt;aaa&lt;/div&gt; &lt;/div&gt; ) &#125;&#125; ref直接等于一个函数，把节点当做参数传递进去，并且给当前组件绑定 newAttr 属性上，后面直接 this.newAttr 这样使用就行了。 使用ref调用子组件里面的方法12345678910111213141516171819//App.jsimport React from 'react';import ReactDOM from "react-dom";import Test from "./Test";class App extends React.Component&#123; componentDidMount()&#123; console.log(this.refs.aaa.getValue()); &#125; render()&#123; return ( &lt;div ref="text"&gt; hellow &lt;Test ref="aaa"/&gt; &lt;/div&gt; ) &#125;&#125;export default App; 12345678910111213//Test.jsclass Test extends React.Component&#123; getValue()&#123; return this.refs.input.value; &#125;render()&#123; return( &lt;div&gt; &lt;input ref="input" type="text" defaultValue="yewenxiang" /&gt; &lt;/div&gt; ) &#125;&#125;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react生命周期]]></title>
    <url>%2F2018%2F09%2F27%2Freact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[什么是组件的生命周期？一个 React 组件的各个生命阶段会自动触发一些函数，这些被称为生命周期函数。具体如下图： 初始化: 获取默认属性值 getDefaultProps() :在组件挂载之前调用一次。 获取实例初始状态 getInitialState() :在组件类创建的时候调用一次，然后返回值被缓存下来。 首次渲染之前 componentWillMount() :服务器端和客户端都只调用一次，在初始化渲染执行之前立即调用。 渲染 render() 。 首次渲染之后 componentDidMount() :在初始化渲染执行之后立刻调用一次，仅客户端有效(服务器端不会调用)。 更新: 属性被修改前 componentWilReceiveProps() :在组件接收到新的props的时候调用，在初始化渲染的时候，该方法不会调用。 判断是否需要更新 shouldComponentUpdate() :在接收到新的 props 或者 state ， 将要渲染之前调用。 更新之前 componentWillUpdate() :在接收到新的 props 或者 state时立刻调用。 渲染 render() 。 更新之后 componentDidUpdate() :在组件的更新同步到DOM之后立刻调用。 销毁: 销毁前 componentWillUnmount() :在组件从DOM中被移除时立刻调用，一般在该方法中执行必要的清理。 一个demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546//App.jsimport React from "react";import Test from "./Test";class App extends React.Component&#123; constructor()&#123; super(); this.state = &#123;num:0,show:true&#125;; console.log("App 初始化获取state值"); &#125; componentWillMount()&#123; console.log("App 组件将要挂载"); &#125; componentWilReceiveProps(nextProps)&#123; console.log("App Props改变后,组件将要更新"); &#125; shouldComponentUpdate(nextProps,nextState)&#123; console.log('App 组件是否应该跟新,改变后Props的值：',nextProps,'改变后state的值：',nextState); if(nextState.num&lt;5)&#123; return true; &#125; return false; &#125; componentWillUpdate(nextProps,nextState)&#123; console.log('App 组件将要跟新,改变后Props的值：',nextProps,'改变后state的值：',nextState); &#125; componentDidUpdate(prevProps,prevState)&#123; console.log('App 组件跟新完毕,Props的上一个值：',prevProps,'state的上一个值：',prevState); &#125; render()&#123; console.log("App 渲染"); return ( &lt;div&gt; &lt;div&gt; 数值：&#123;this.state.num&#125; &lt;/div&gt; &lt;button onClick=&#123;()=&gt;this.setState(&#123;num:this.state.num+1&#125;)&#125;&gt;加一&lt;/button&gt; &lt;Test childNum = &#123;this.state.num&#125; /&gt; &lt;/div&gt; ) &#125; componentDidMount()&#123; console.log("App 组件挂载完毕"); &#125;&#125;export default App; 12345678910111213141516171819202122232425262728293031323334//Test.jsimport React from "react";export default class Test extends React.Component&#123; constructor()&#123; super(); console.log("Test 初始化获取state值"); &#125; componentWillMount()&#123; console.log("Test 组件将要挂载"); &#125; componentWilReceiveProps(nextProps)&#123; console.log("Test Props改变后,组件将要更新"); &#125; componentWillUpdate(nextProps,nextState)&#123; console.log('Test 组件将要跟新,改变后Props的值：',nextProps,',改变后state的值：',nextState); &#125; componentDidUpdate(prevProps,prevState)&#123; console.log('Test 组件跟新完毕,Props上一个的值：',prevProps ,'，state上一个的值：',prevState); &#125; componentWillUnmount()&#123; console.log(`我要被销毁了`); &#125; render()&#123; console.log("Test 渲染"); return ( &lt;div&gt;我是test组件：&#123;this.props.childNum&#125;&lt;/div&gt; ) &#125; componentDidMount()&#123; console.log("Test 组件挂载完毕"); &#125;&#125; 刷新后初始化，console中输出 12345678App 初始化获取state值App 组件将要挂载App 渲染Test 初始化获取state值Test 组件将要挂载Test 渲染Test 组件挂载完毕App 组件挂载完毕 点击加1按钮，改变了 this.state.num 的值后： 1234567App 组件是否应该跟新,改变后Props的值： Object &#123;&#125; 改变后state的值： Object &#123;num: 1, show: true&#125;App 组件将要跟新,改变后Props的值： Object &#123;&#125; 改变后state的值： Object &#123;num: 1, show: true&#125;App 渲染Test 组件将要跟新,改变后Props的值： Object &#123;childNum: 1&#125; ,改变后state的值： nullTest 渲染Test 组件跟新完毕,Props上一个的值： Object &#123;childNum: 0&#125; ，state上一个的值： nullApp 组件跟新完毕,Props的上一个值： Object &#123;&#125; state的上一个值： Object &#123;num: 0, show: true&#125; 注意：nextProps 和 nextState 两个参数是接收的一个对象。componentDidUpdate(prevProps,prevState)拿到的是上一个值。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react组件之间通信]]></title>
    <url>%2F2018%2F09%2F27%2Freact%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[组件之间如何通信一个组件如果无法做到通信是无法得到很好的复用的，因为有时候组件复用我们希望组件的UI会有点点区别,下来实现一个简单的通信来说明。 12345678910111213141516//Btn.jsimport React from &apos;react&apos;;class Btn extends React.Component&#123; render()&#123; let styles = &#123; padding:this.props.padd, fontSize:&quot;18px&quot;, backgroundColor:this.props.bg &#125; console.log(this.props); return ( &lt;button style=&#123;styles&#125;&gt;&#123;this.props.title&#125;&lt;/button&gt; ) &#125;&#125;export default Btn; 123456789101112131415//App.jsimport React from &apos;react&apos;;import Btn from &quot;./Btn&quot;;class App extends React.Component&#123; render()&#123; return ( &lt;div&gt; &lt;Btn title=&quot;叶文翔&quot; bg=&apos;yellow&apos; padd=&apos;20px 30px&apos;/&gt; &lt;Btn title=&quot;向往&quot; bg=&apos;#777&apos;/&gt; &lt;Btn title=&quot;田冬雪&quot;/&gt; &lt;/div&gt; ) &#125;&#125;export default App; 上面 Btn.js组件 导出到 App.js组件 中，那么App组件就是Btn组件的父组件，我们在父组件App自定义标签中插入我们自定义的属性，然后在 Btn.js 文件的 render() 函数中打印 this.props 发现得到下图: 说明 this.props 可以拿到我们自定义属性的一个对象，然后在我们的 Btn.js 文件中，把需要自定义的属性全部用 this.props.自定义属性名 替换掉就行了，能够极大的提高组件的复用率。 组件中的默认属性上面有个问题，如果没有传入相应的属性和属性值，组件可能会得不到正确的显示，这时候我们需要定义组件的默认属性了。定义方法： 123456//Btn.jsBtn.defaultProps = &#123; title:&apos;defaultTitle&apos;, bg:&apos;#00bcd4&apos;, padd:&apos;10px 20px&apos;&#125; 这样当我们忘记传对应的属性的时候，组件就会显示默认的属性。 组件通信更好的方式如果我们定义的属性很多，或者从后台传过来的属性来渲染，就会使用下面的方式 123456789101112131415161718192021//Card.jsimport React from &apos;react&apos;;class Card extends React.Component&#123; render()&#123; return ( &lt;div className=&quot;card&quot;&gt; &lt;div className=&quot;card-index&quot;&gt;&#123;this.props.index&#125;&lt;/div&gt; &lt;div className=&quot;card-desc&quot;&gt; &lt;h3&gt;&#123;this.props.title&#125;&lt;/h3&gt; &lt;p&gt;&#123;this.props.data&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;Card.defaultProps = &#123; index:1, title:&quot;默认的一个标题&quot;, data:&quot;2017.2.20&quot;&#125;export default Card; 12345678910111213141516171819202122232425262728293031323334//App.jsimport React from &apos;react&apos;;import Card from &quot;./Card&quot;;import &quot;./main&quot;;let arr = [ &#123;index:1,title:&quot;标题一&quot;,date:&quot;2017.2.22&quot;&#125;, &#123;index:2,title:&quot;标题二&quot;,date:&quot;2017.2.23&quot;&#125;, &#123;index:3,title:&quot;标题三&quot;,date:&quot;2017.2.24&quot;&#125;, &#123;index:4,title:&quot;标题四&quot;,date:&quot;2017.2.25&quot;&#125;, &#123;index:5,title:&quot;标题五&quot;,date:&quot;2017.2.26&quot;&#125;]class App extends React.Component&#123; constructor()&#123; super(); this.state=&#123; date:arr &#125; &#125; render()&#123; return ( &lt;div&gt; &#123; this.state.date.map( item =&gt; &lt;Card key=&#123;Math.random()&#125; title=&#123;item.title&#125; index=&#123;item.index&#125; date=&#123;item.date&#125; /&gt;) &#125; &#123;/* 或者使用下面的方式 */&#125; &#123;/* &#123;arr.map( item =&gt; &lt;Card key=&#123;Math.random()&#125; &#123;...item&#125; /&gt; )&#125; */&#125; &lt;/div&gt; ) &#125;&#125;export default App; 组件属性的数组最好交给 state 属性来统一管理。 {...item} 这种写法更加的简便，arr 数组中每个对象都被当做了参数来传递，使用 .map() 方法，把属性插入了 &lt;Card /&gt; 这个组件中。Spread 扩展操作符: {...item} ,直接把对象铺开放在了 &lt;Card /&gt; 组件中。 子组件设置属性验证通过 Btn.propTypes = {} 来设置属性的格式，当父组件传的值不符时，浏览器会报错。 123456//Btn.jsBtn.propTypes = &#123; title:React.PropTypes.string, bg:React.PropTypes.string, padd:React.PropTypes.string&#125; 子组件传递函数和参数123456789101112131415161718192021//父组件 App.jsclass App extends React.Component&#123; constructor()&#123; super(); this.state=&#123; num:0 &#125; &#125; addNum(num2)&#123; this.setState(&#123;num:this.state.num + num2&#125;); &#125; render()&#123; return ( &lt;div&gt; 数值是：&#123;this.state.num&#125; &lt;br /&gt; &lt;Btn title=&quot;减1&quot; bg=&quot;#666&quot; padd=&apos;20px 30px&apos; addNum = &#123;this.addNum.bind(this,-1)&#125;/&gt; &lt;Btn title=&quot;加1&quot; bg=&quot;pink&quot; padd=&apos;20px 30px&apos; addNum = &#123;this.addNum.bind(this,1)&#125;/&gt; &lt;/div&gt; ) &#125;&#125; 12345678910111213141516171819//子组件 Btn.jsclass Btn extends React.Component&#123; // handleClick()&#123; // this.props.addNum(); // &#125; render()&#123; let styles = &#123; padding:this.props.padd, fontSize:&quot;18px&quot;, backgroundColor:this.props.bg &#125; console.log(this.props); return ( // &lt;button style=&#123;styles&#125; onClick = &#123;this.handleClick.bind(this)&#125;&gt;&#123;this.props.title&#125;&lt;/button&gt; // 或者 &lt;button style=&#123;styles&#125; onClick = &#123;() =&gt; this.props.addNum()&#125;&gt;&#123;this.props.title&#125;&lt;/button&gt; ) &#125;&#125; 子组件设置函数的验证12345//Btn.jsBtn.propTypes = &#123; addNum:React.PropTypes.func.isRequired //必须传一个函数，否则报错。&#125; 如何在组件中嵌套组件(this.props.children)this.props.children 表示组件所有的子节点，也就是在父组件中包含的标签。它有三种可能的值： 如果当前组件没有子节点，它就是 undefined 如果有一个子节点，数据类型是 object 如果有多个子节点，数据类型是 array 123456789101112131415161718192021222324//Children.jsimport React from &apos;react&apos;;import ReactDOM from &quot;react-dom&quot;;import Son from &quot;./Son&quot;;import Test from &quot;./Test&quot;;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; aaa &lt;Son&gt; bbb &lt;Test&gt;&lt;/Test&gt; &lt;Test&gt;&lt;/Test&gt; &lt;Test&gt;&lt;/Test&gt; &lt;Test&gt;&lt;/Test&gt; &lt;Test&gt;&lt;/Test&gt; &lt;/Son&gt; &lt;/div&gt; ) &#125;&#125;export default App; 1234567891011121314151617//Son.jsimport React from &apos;react&apos;;import ReactDOM from &quot;react-dom&quot;;class Son extends React.Component&#123; componentDidMount()&#123; &#125; render()&#123; console.log(this.props.children); //打印出 [&quot;bbb&quot;, Object, Object, Object, Object, Object] return( &lt;div&gt; &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125;export default Son; 123456789101112131415//Test.jsimport React from &apos;react&apos;;import ReactDOM from &quot;react-dom&quot;;class Test extends React.Component&#123; render()&#123; console.log(this.props.children); //输出5个 undefined return( &lt;div&gt; 我是Test组件 &lt;/div&gt; ) &#125;&#125;export default Test; React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object 123456789return ( &lt;ol&gt; &#123; React.Children.map(this.props.children, function (child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;; &#125;) &#125; &lt;/ol&gt; );]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bind和super的理解]]></title>
    <url>%2F2018%2F09%2F27%2Fbind%E5%92%8Csuper%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[bindthis 在不同的执行上下文中指向不同的对象，这样往往会造成 undefined 错误，bind 要解决的就是明确函数在执行的时候 this 的指向。不使用bind,下面的函数执行会报错 1234567891011121314151617var Person = &#123; name: 'yewenxiang', talk: function() &#123; console.log(`My name is $&#123;this.name&#125;`); &#125;&#125;Person.talk();let plzTalk = Person.talk;plzTalk();//------------------------等价于let plzTalk = function() &#123; console.log(`My name is $&#123;this.name&#125;`);&#125;plzTalk(); 使用bind之后: 1234567var Person = &#123; name: 'yewenxiang'&#125;let plzTalk = function() &#123; console.log(`My name is $&#123;this.name&#125;`); &#125;;plzTalk.bind(Person)(); 总结一下： bind 的作用就是把一个对象（作为 bind 的参数传入），绑定到这个函数中的 this 之上。 再举个例子加深理解： 123456789101112131415161718function talk() &#123; console.log(this.sound);&#125;let Person = &#123; sound: 'Hi there!', speak: talk&#125;Person.speak(); // 可以正确输出 sound 的值//----------------------------等价于let Person = &#123; sound: 'Hi there!', speak: function () &#123; console.log(this.sound); &#125;&#125;Person.speak(); super调用父类方法super 代表父类。主要有两个用途： 使用 super() 呼叫父类的 constructor() 使用 super.functionName() 调用父类中的 static 方法 super()的作用子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类就得不到 this 对象。ES6的继承机制，实质是先创造父类的实例对象 this（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。 1234567891011121314151617181920class Father &#123; constructor(familyName)&#123; this.familyName = familyName; &#125; static sayHello() &#123; console.log('hello'); &#125;&#125;class Son extends Father &#123; constructor() &#123; super(); this.height = 170; // 没有上一行的 super() ，这里的 this 就不让用 &#125; static hello() &#123; super.sayHello(); // 调用父类的静态方法 &#125;&#125;let tom = new Son('Wang', 160);console.log(Son.hello());]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>bind</tag>
        <tag>super</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6快速入门]]></title>
    <url>%2F2018%2F09%2F26%2FES6%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言ECMAScript简称就是ES,你可以把它看成是一套标准,JavaScript就是实施了这套标准的一门语言 现在主流浏览器使用的是ECMAScript5。 ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。在项目中80%的时间用到的ES6语法只占其20%，所以我们暂时先集中精力把这20%学好，那就差不多够用了，剩下的可以看书或是查文档，现学现用。 Let + Const 块级作用域和常量let和const的出现让 JS 有了块级作用域，还可以像强类型语言一样定义常量。由于之前没有块级作用域以及 var 关键字所带来的变量提升，经常给我们的开发带来一些莫名其妙的问题。 下面看两个简单的demo理解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// demo 1function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125;// demo 2const PI = 3.1415;console.log(PI); // 3.1415PI = 3;console.log(PI); // TypeError: "PI" is read-onlyif (true) &#123; var a = "a"; // 期望a是某一个值&#125;console.log(a);if(true)&#123; let name = 'zfpx';&#125;console.log(name);// ReferenceError: name is not defined// 嵌套循环不会相互影响for (let i = 0; i &lt; 3; i++) &#123; console.log("out", i); for (let i = 0; i &lt; 2; i++) &#123; console.log("in", i); &#125;&#125;//结果 out 0 in 0 in 1 out 1 in 0 in 1 out 2 in 0 in 1重复定义会报错if(true)&#123; let a = 1; let a = 2; //Identifier 'a' has already been declared&#125;不存在变量的提升console.log(i)let i=10;结果 i is not defined// 闭包新写法// 以前;(function () &#123;&#125;)();现在&#123;&#125; 解构解构意思就是分解一个东西的结构,可以用一种类似数组的方式定义N个变量，可以将一个数组中的值按照规则赋值过去。 123456789101112var [name,age] = ['zfpx',8];console.log(name,age); // zfpx 8var [x,y]=getVal(),//函数返回值的解构 [name,,age]=['zf','male','secrect'];//数组解构function getVal() &#123; return [ 1, 2 ];&#125;console.log('x:'+x+', y:'+y);//输出：x:1, y:2console.log('name:'+name+', age:'+age);//输出： name:zf, age:secrect 数组、对象和字符串的解构赋值示例： 123456789101112131415'use strict';// 数组的解构赋值let [foo, [[bar], baz]] = [1, [[2], 3]];console.log(foo); // 1console.log(bar); // 2console.log(baz); // 3// 对象的解构赋值var &#123; foo, bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;console.log(foo); // "aaa"console.log(bar ); // "bbb"// 字符串的解构赋值const [a, b, c, d, e] = 'hello';console.log(a + b + c + e); // 'hello' Arrows 箭头函数 箭头函数简化了函数的的定义方式，一般以 “=&gt;” 操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。 箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数，从而避免了this指向的问题。 123456789101112131415161718192021//以前let [a,b]=[1,2];function add(a,b) &#123; console.log(a+b);&#125;add(a,b);//现在let add = (a,b) =&gt; console.log(a+b);//forEachvar numbers = [1, 2, 3, 4];numbers.forEach(function(item, index, array) &#123; console.log(item + "\t" + index + "\t" + array);&#125;);var array = [1, 2, 3];//传统写法array.forEach(function(v, i, a) &#123; console.log(v);&#125;);//ES6array.forEach(v = &gt; console.log(v));//输入参数如果多于一个要用()包起来，函数体如果有多条语句需要用&#123;&#125;包起来 Template Strings 字符串模板字符串模板相对简单易懂些。ES6中允许使用反引号 来创建字符串，此种方法创建的字符串里面可以包含由美元符号加花括号包裹的变量${vraible}。如果你使用过像C#等后端强类型语言的话，对此功能应该不会陌生。 123456789//产生一个随机数var num = Math.random();//将这个数字输出到consoleconsole.log(`your num is $&#123;num&#125;`);let name = 'guoyongfeng';let age = 18;console.log(`$&#123;name&#125; was $&#123;age&#125;`) Default + Rest + SpreadDefault 默认参数值现在可以在定义函数的时候指定参数的默认值了，而不用像以前那样通过逻辑或操作符来达到目的了。 12345678910111213function sayHello(name)&#123; //传统的指定默认参数的方式 var name=name||'dude'; console.log('Hello '+name);&#125;//运用ES6的默认参数function sayHello2(name='dude')&#123; console.log(`Hello $&#123;name&#125;`);&#125;sayHello();//输出：Hello dudesayHello('zf');//输出：Hello zfsayHello2();//输出：Hello dudesayHello2('zf');//输出：Hello zf Rest 剩余参数不定参数是在函数中使用命名参数同时接收不定数量的未命名参数。这只是一种语法糖，在以前的JavaScript代码中我们可以通过 arguments 变量来达到这一目的。 不定参数的格式是三个句点后跟代表所有不定参数的变量名。比如下面这个例子中，…x代表了所有传入add函数的参数。 1234567// restfunction restFunc(a, ...rest) &#123; console.log(a) console.log(rest)&#125;restFunc(1);restFunc(1, 2, 3, 4); other: 1234567//将所有参数相加的函数function add(...x)&#123; return x.reduce((m,n)=&gt;m+n);&#125;//传递任意个数的参数console.log(add(1,2,3));//输出：6console.log(add(1,2,3,4,5));//输出：15 Spread 扩展操作符扩展操作符则是另一种形式的语法糖，它允许传递数组或者类数组直接做为函数的参数而不用通过apply。 12345678910var people=['zf','John','Sherlock'];function sayHello(people1,people2,people3)&#123; console.log(`Hello $&#123;people1&#125;,$&#123;people2&#125;,$&#123;people3&#125;`);&#125;//但是我们将一个数组以拓展参数的形式传递，它能很好地映射到每个单独的参数sayHello(...people);//输出：Hello zf,John,Sherlock//而在以前，如果需要传递数组当参数，我们需要使用函数的apply方法sayHello.apply(null,people);//输出：Hello zf,John,Sherlock Class, extends, super 类的支持以前，如果我们需要模拟一个js的类，一般会采用构造函数加原型的方式。 12345678910function Point(x,y)&#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;var point = new Point(6,3);console.log(point.toString());//(6,3) ES6中添加了对类的支持，引入了class关键字（其实class在JavaScript中一直是保留字，目的就是考虑到可能在以后的新版本中会用到，现在终于派上用场了）。 JS本身就是面向对象的，ES6中提供的类实际上只是JS原型模式的包装。现在提供原生的class支持后，对象的创建，继承更加直观了，并且父类方法的调用，实例化，静态方法和构造函数等概念都更加形象化。 类在ES6中运用案例： 123456789101112131415161718192021222324252627282930//类的定义class Animal &#123; //ES6中新型构造器 constructor(name) &#123; this.name = name; &#125; //实例方法 sayName() &#123; console.log('My name is '+this.name); &#125;&#125;//类的继承class Programmer extends Animal &#123; constructor(name) &#123; //直接调用父类构造器进行初始化 super(name); &#125; program() &#123; console.log("I'm coding..."); &#125;&#125;//测试我们的类var animal=new Animal('dummy'),zf=new Programmer('zf');animal.sayName();//输出 ‘My name is dummy’zf.sayName();//输出 ‘My name is zf’zf.program();//输出 ‘I'm coding...’//定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 Modules 模块在ES6标准中，JavaScript原生支持module了。这种将JS代码分割成不同功能的小块进行模块化的概念是在一些三方规范中流行起来的，比如CommonJS和AMD模式。 将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用。 不过，还是有很多细节的地方需要注意，我们看例子： 123456789101112131415// point.jsexport default class Point &#123; constructor (x, y) &#123; public x = x; public y = y; &#125; &#125;// myapp.js//这里可以看出，尽管声明了引用的模块，还是可以通过指定需要的部分进行导入import Point from "point";var origin = new Point(0, 0);console.log(origin); export1234567891011// demo1：简单使用export var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958;// 等价于var firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;; 123456789// demo2：还可以这样function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; 1234567// demo3：需要注意的是export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。// 报错function f() &#123;&#125;export f;// 正确export function f() &#123;&#125;; 1234//export的默认输出export default function () &#123; console.log('foo');&#125; 为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。这样其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。 需要注意的是，这时import命令后面，不使用大括号。 最后需要强调的是：ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。 CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 ES6模块的运行机制与CommonJS不一样，它遇到模块加载命令import时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值，换句话说，ES6的输入有点像Unix系统的”符号连接“，原始值变了，import输入的值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 import1234567891011// 1import $ from 'jquery';// 2import &#123;firstName, lastName, year&#125; from './profile';// 3import React, &#123; Component, PropTypes &#125; from 'react';// 4import * as React from 'react';]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[coding-github上传代码操作]]></title>
    <url>%2F2018%2F09%2F26%2Fcoding-github%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[coding github上传代码操作基本是相同的。 首先是项目文件名字有点区别，coding项目文件夹叫 用户名 ，github项目文件夹叫 用户名.github.io 然后是分支 coding-pages gh-pages 不同 id_rsa.pub 密钥是共用的 一般项目的push操作流程 mkdir yewenxiang.github.io 创建项目文件夹 git init 初始化项目文件夹，添加了一个.git隐藏文件 这步是里面放一些文件，然后做版本 git add -A git commit -m&quot;改动内容&quot; github 上建一个同名的仓库，注意不能点击初始化仓库的选项,这会造成服务器仓库和本地仓库版本不一致，导致版本冲突 复制仓库地址到bash命令行 例如： git remote add origingit@github.com:funnydeer/funnydeer.github.io.git 记录仓库地址,在项目文件夹 .git/config 文件中可查看。这有两种方式： 一种是 http 方式，每次推送都要输入用户名和密码,而且不安全，不推荐这种方法 另一种是 ssh 方式,需要 bash命令行输入 ssh-keygen 会生成两个密钥 取公钥 ~/.ssh/id_rsa.pub 添加到 github 设置上去 建立互信。 git push -u origin master 首次执行时，在远端创建 master 分支，并且把本地的代码上传到这个分支之上. 后续推送操作都只需 git push就行了。 一些操作12git remote add origin git@git.coding.net:yewenxiang/yewenxiang.git修改 `.git/config` 文件中的属性，添加仓库的地址 12git push -u origin maste推送仓库当前版本到主分支之上 12ssh-keygen生成一个公钥和私钥 在 `cd ~/.ss` 文件夹下 12git branch查看本地的分支 12git checkout -b coding-pages在本地创建一个 `coding-pages` 分支 12git push -u origin coding-pages首次执行时，在远端创建 `coding-pages` 分支，并且把本地的代码上传到这个分支之上]]></content>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm的使用方法]]></title>
    <url>%2F2018%2F09%2F26%2Fnpm%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[npm 是随同node一起安装的包管理工具 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 模块初始化1npm init cd 到项目文件夹下输入 npm init 这样就初始化了一个node的项目，文件夹里面生成了一个 package.json 文件，里面的信息为初始化项目时终端中输入的信息。 script 字段中可以定义我们自己的一些脚本 npm安装模块1npm install &lt;Module Name&gt; --save 这时，就会在我们的项目文件夹下生成一个 node_modules 的文件夹,里面会有安装的包。 本地安装 1234npm install &lt;Module Name&gt; --save版本名和版本号记录在dependencies字段中npm install express --save-dev版本名和版本号记录在devDependencies字段中 dependencies字段中的包信息是项目上线时依赖的包，devDependencies字段中的包信息是开发项目时需要的包工具。 全局安装 1npm install &lt;Module Name&gt; -g 12npm ls -g查看全局安装的模块 不建议使用全局安装，因为多人协作时，可能会导致开发环境不同（包的版本不同）导致一些问题。 npm 卸载模块1npm uninstall &lt;Module Name&gt; npm 跟新模块1npm update &lt;Module Name&gt; npm 搜索模块1npm search &lt;Module Name&gt; npm 发布模块1npm publish 发布前需要输入以下命令 1npm adduser 其他常用命令12npm helpnpm cache clear //可以清空npm本地的缓存 后续学习资源 阮一峰的教程]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nvm安装node.js的一些基本操作]]></title>
    <url>%2F2018%2F09%2F26%2Fnvm%E5%AE%89%E8%A3%85node-js%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[安装node方式很多，最好使用nvm (node.js的版本控制工具，可以同时安装多个node.js).使用 nvm install v... 安装node 不会覆盖之前使用nvm装的node版本，因为所有的 .node 文件夹都是在 .nvm 文件夹下的，不会被覆盖。 安装 nvm 可以去 github上去找安装 nvm 安装 nvm1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash 12nvm ls-remote查看可以安装的node.js的版本 12nvm ls查看本地已安装 node版本 12nvm uninstall 8.4.0卸载本地安装的 node8.4.0 12nvm install v7.4.0安装 7.4.0版的node.js npm node的包管理工具 设置默认 node 版本1nvm alias default 5.10.1 执行上面语句，重启 shell 之后，执行 node -v 查看切换后的node 版本]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>nvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的一些命令操作]]></title>
    <url>%2F2018%2F09%2F26%2Fgit%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[安装git123sudo apt-get updatesudo apt-get install gitsudo npm install git apt-get 是 ubuntu 系统（deepin其实就是ubuntu的一个变种）的软件安装命令 12git --version获取git的版本号 git本地化的步骤 第一步：在项目文件夹中运行 git init 来初始化一个仓库,会建立一个.git 的隐藏文件夹。 第二步：git add -A 添加修改后的版本到 .git 文件夹中， -A是添加所有文件的意思 第三步: git commit -m&quot;留言内容&quot; 做成一个git本地的一个版本，-m 是 message 留言的意思，这个是必须的。 这一步对于新装的git用户来说还要告诉git 用户名和邮箱。 12git config --global user.name "yewenxiang"git config --global user.email "yewenxiang23@gmail.com" git 其他的一些命令1git log -p log 是日志的意思, -p是patch (补丁,就是修改内容)的缩写 使用 brew install tig 安装tig包后，查看版本日志方便了很多，选中其中一个版本按 D 可以查看详细信息 按 Q 可以退出 git 回滚的操作 修改后没做版本 回到上个 git commit -m&quot;...&quot; 的版本可以使用 1git reset --hard HEAD 修改后做了版本 回到上个版本可以使用 1git reset --hard HEAD~ 在用户的主目录文件夹下有一个 .gitconfig 的隐藏文件，可以修改里面的属性来配置git. 123[alias]throw = reset --hard HEADthrowh = reset --hard HEAD~ 添加上述代码后 每次回滚操作只需输入 git throw 或者 git throwh 就可以了 git 取消回滚的操作git log 可以查看项目各个版本 也就是 git commit -m&quot;...&quot; 做的本地版本，有时候我们做了 回滚 的操作（此时，输入git log，由于回滚到了上一个版本，所以回滚前的版本不见了。 ），但是又需要改变为 回滚前 的状态使用以下步骤。 git reflog 来查看记录的HEAD历史，当做reset,checkout等操作时候，这些操作会被记录在 reflog 中,就可以查看 回滚前 操作的版本的哈希值，取前7位 git reset --hard 7位哈希值 就可以被找回reset操作的那个版本 如果你因为reset等操作丢失一个提交的时候，你总是可以把它找回，除非你的操作已经被git当做垃圾处理了，一般是在30天后执行。 git clone 命令要想把 github 上的一个项目代码下载到本地有两种方式，一种就是普通下载（ download ）。但是，开发者 基本上会选择另外一种方式，就是 clone 。1git clone git@github.com:happypeter/digicity.git clone 的特点就是不仅仅可以得到最新代码，而且可以得到整个改版历史。而普通下载只能得到最新版本。 git 各个命令的作用 git push 把本地仓库中有，而远端对应仓库中没有的版本推送到远端 git pull 把远端仓库中有，而本地对应仓库中没有的版本拉到本地 git clone 把远端仓库，克隆到本地 如何协同合作在github 上面打开项目仓库，点 setting -&gt; Collaborators 然后输入需要合作的用户名称，添加后点击 Copy invite link 把网址发给对方确认，就可以分工合作了。 在存在本地版本与服务器版本不同时，git push 会失败。此时需要 git pull来更新最新的版本。前提是修改的地方没有冲突 git pull 才会成功。 如果别人修改了文件中一个地方，你本地又修改了同一个地方，此时就会造成冲突，git pull 会不成功，并且会在冲突的位置添加注释，需要和对方商量到底用哪个人的方案，如果用我的方案，只需要把注释删除，然后再 git pull 即可，此时服务器上面就合并成了你的方案，然后再版本三步走，推送你的代码就行啦。 git 分支的操作每次我们对新仓库推送代码时都要执行类似于以下两行代码 git remote add origin git@github.com:happypeter/digicity.git 设置仓库的地址，修改 .git/config 文件中的属性 git push -u origin master 推送仓库当前版本到主分支之上,同时在远端创建了主分支 12git checkout -b dev在本地创建新分支bev 本地创建新分之后，新分支的指针是指向 master 分支的，也就是新分支的文件和主分支的文件是相同的（做了一次拷贝），一般是修改新分支下的文件后，做版本，然后 git push -u origin dev 在远程创建 dev 分支，同时把本地的内容推送到远端的 dev 分支之上，注意这需要切换到 dev 分支上操作， 12git branch查看本地分支 12git checkout 分支名切换分支 如何删除分支 如果有两个分支 master dev , 首先需要切换到 master 分支之上 git branch -D dev 这样本地 dev 分支就没有了, 但是 github 上的没有受到影响 git push origin :dev 这样可以把 github上的 dev 分支删除 获取远端新分支 git branch -a 列出远端所有分支 git checkout -b dev origin/dev 作用是checkout远程的dev分支，在本地起名为dev分支，并切换到本地的dev分支 合并分支一般 master 分支上的代码是随时可以部署的项目，有时候我们需要添加新功能，这需要创建新的分支去测试，如果没问题了，则合并到主分支之上 首先切换到主分支之上。 git merge dev 把 dev 分支上的内容合并到 master 分支之上。 只是在本地进行了合并，还需要 git push 推送到远端仓库。 如果需要删除这个分支，则进行上面的删除分支操作。 补充.gitignore 文件中填写要忽略的文件或者文件名字，也就是不做版本的时候不会跟踪，也不会上传到github服务器上面，一般文件建在 .git 同级目录下面。 学习git资源 Atom 爱上 JS 驾驭命令行怪兽 Git北京]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基本命令]]></title>
    <url>%2F2018%2F09%2F26%2FLinux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[MAC查看外网IP1curl ipinfo.io/json cd跳转命令 Change Directory翻译过来就是改变文件夹 ,cd后面要跟一个文件夹的名字1cd dir 输入文件夹名字时支持tab补齐 两个点表示跳到上一级文件夹中 eg: cd .. cd跳转又分为相对路径和绝对路径 相对路径 打开当前文件夹里面的文件夹,或者 cd .. 跳到上一个文件夹 绝对路径 使用绝对路径最大的好处是跟当前位置无关 以老祖宗文件夹 / 打头,例如：不管我们在哪 cd / 都可以跳到根目录中, cd /Users/wenxiangye 可以直接跳到用户主目录 等价于 cd ~. 打印出的当前位置1pwd 列出当前文件夹中的所有文件和文件夹12ls需要列出隐藏的文件夹时用 `ls -a` 创建一个文件12touch fileatom file 通常使用atom编辑器创建一个文件 创建一个文件夹1mkdir dir 删除文件夹 remove12rm file删除file文件 12rm -r dir删除文件夹 注意 .git 文件夹有写保护 需要使用 rm -rf dir 来强制删除 12rm -r *可以删除当前位置的所有文件个文件夹 拷贝操作 copy12cp file1 file2拷贝文件file1 变成 file2, file1和file2就文件名字不同 12cp -r dir1 dir2拷贝文件夹dir1 变成 dir2, dir1和dir2文件夹中的内容是相同的 12mv aaa/* bbb把文件夹aaa中的所有文件全部拷贝到bbb文件夹中 重命名和移动操作 move123mv file dirmv dir1 dir2移动file文件到dir文件夹中 可以通过file dir1来查看文件的类型 12mv file1 file2mv dir dir1 这里是把文件file1改名成了file2,当前目录不能存在 file2和dir1文件，如果存在则是移动和替换操作 12mv file ..移动文件到上一级目录 查看文件12cat file会列出文件里面的内容 普通用户和超级用户我们平时在用户主目录文件夹里面，用普通用户的身份就能去增删改的操作了，但是在其他目录下面需要超级用户的身份才能去执行操作，实现的方式:12sudo rm file上面的命令可以用超级用户权限执行一个命令 1sudo su 可以直接化身超级用户,可以输入 whoami 打印出当前用户的身份，退出超级用户成普通用户，敲 Ctrl-D]]></content>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack3.0+基础学习]]></title>
    <url>%2F2018%2F09%2F25%2Fwebpack3-0-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[一个webpack demo 首先是建立项目结构 根目录新建 src 文件夹 (开发环境时的代码) 根目录新建 dist 文件夹（生产环境的代码） webpack 打包的本质是把 src下的入口文件 entry.js 文件，及其相关联的文件,打包成bundle.js文件，并且放在 dist 文件夹下面 webpack 的打包命令： 如果是全局安装的webpack : $webpack src/entry.js dist/bundle.js。 如果是项目中安装的webpack : $./node_modules/.bin/webpack src/entry.js dist/bundle.js 一般我们webpack不会使用全局安装的方式，会造成版本冲突导致的问题。而使用项目中安装的webpack 命令行每次打包输入又太长，可以将命令行写进 package.json 文件里面的 script 标签中： 123"scripts": &#123; "bundle":"./node_modules/.bin/webpack src/entry.js dist/bundle.js" &#125;, 这样每次打包只需要 $npm run bundle 就可以了。 小技巧： bundle 改成 start ，只需要 npm start。全局安装 live-server 这个插件可以在本地跑一个服务器，使项目跑在 8080 这个端口。 webpack配置文件在项目的根目录新建 webpack.config.js 文件，配置的基本结构： 1234567module.exports = &#123; entry: &#123;&#125;, output: &#123;&#125;, module: &#123;&#125;, //模块解读css，打包css，图片转换压缩等配置。 plugins: [], //插件 devServer: &#123;&#125;, //配置开发服务&#125; 上面将入口出门配置信息写进了 script 脚本里面，然后使用 npm start 来跑这段脚本，也就是跑这段命令，这种方式来配置是非常单一的，没有更多的配置选项，如果做多入口多出口的配置就无法实现了。正确开发的姿势是将配置信息写进 webpack.config.js 文件中： 12345678910const path = require('path'); //注意引入 path 模块module.exports = &#123; entry: &#123; entry:'./src/entry.js' //入口文件路径 &#125;, output: &#123; path:path.resolve(__dirname,'dist'), //出口文件路径 filename:'bundle.js' //打包后的文件名 &#125;&#125; path.resolve(__dirname,&#39;dist&#39;) 代码解读： path：node核心模块之一,需要引入path 。 __dirname：当前文件所在目录的完整绝对路径。 resolve：resolve 会将参数中的路径或路径片段的序列解析为一个绝对路径，这样即使项目迁移，地址变更，只要保证相对路径正确即可。 代码解读：出口文件存放路径为当前文件夹下的 dist 文件夹中。 多入口 多出口 配置在 src 下新建一个 entry2.js 文件，也就是第二个入口文件，加入js代码，更改配置。12345678entry: &#123; //固定命名 entry: './src/entry.js', //这里的entry名字是自己定义的 entry2: './src/entry2.js', &#125;, output: &#123; path:path.resolve(__dirname,'dist'), filename:'[name].js' //[name] 打包的出口文件名 和 入口文件名是一样的 &#125;, 更改 dist/index.html 中引入的js文件，就可以查看效果了。 注意：两个入口肯定需要两个出口文件对应 服务和热更新自己配置一个本地的服务器，首先需要在项目中安装 webpack-dev-server 这个包。1npm i webpack-dev-server --save-dev shell 中输入命令 webpack-dev-server ，是无法识别的，因为没有全局安装，环境变量中也就没有存在命令所在的目录。我们需要再 package.json 中加入:1"server":"./node_modules/.bin/webpack-dev-server --open" 后面加上参数 --open 运行后直接弹出浏览器 这样配置后 npm run server 他会去找 webpack.config.js 文件中的服务器配置信息： 123456devServer: &#123; contentBase: path.resolve(__dirname, 'dist'), //监听的文件夹 host: 'localhost', //服务器地址，本机ip地址，不建议使用locahost ，防止映射表被修改，出现解析不到的情况。ifconfig 查看 本机ip compress: true,//服务器端压缩 port:1717 //服务器端口，默认80 &#125;, 注意：在翻墙的情况下 host: 填写本机ip 会报错，使用 localhost 打包css文件首先需要安装两个包 style-loader css-loader 来实现对css 文件的转换。 1npm i style-loader css-loader --save-dev style-loader:处理css中的 url css-loader:处理css中的样式 在src文件夹中建立css文件,并且在 入口文件 或者 入口依赖的其他js文件 中引入：1import css from './css/index.css'; webpack.config.js中的配置： 12345678module: &#123; rules: [ &#123; test: /\.css$/, //用正则表达式的形式来找到处理的文件 use: ['style-loader', 'css-loader']//使用哪些loader来处理 &#125; ] &#125;, 另一种常用写法可以使每个loader 可以配置选项：123456789101112module: &#123; rules: [ &#123; test: /\.css$/, use: [&#123; loader:"style-loader" &#125;, &#123; loader:"css-loader" &#125;] &#125; ] &#125;, 压缩js文件对js文件做代码压缩，需要使用到 webpack 内置的 uglifyjs-webpack-plugin 这个插件。 123456//webpack.config.jsconst UglifyJSPlugin = require('uglifyjs-webpack-plugin');plugins: [ new UglifyJSPlugin() ], 然后 npm start 发现打包出来的代码被压缩了。 这里遇到了一个坑。。。 接上一步开启服务器 npm run server ，命令行报错 ERROR in entry.js from UglifyJsUnexpected token: name (urlParts) [entry.js:325,4] 原因在于：没有区分 开发环境 和 生产环境 。开发环境中代码是不需要压缩的。如果压缩了，调试没有办法找到对应的行号。代码压缩只需要再 生产环境 中进行，在开发环境中压缩代码，跑服务器造成了冲突，具体情况不清楚。正常的项目开发是不会产生这样的问题的，都会有一个 开发使用的配置文件 和 生产使用的配置文件 。 HTML文件的打包一般项目开发是严格区分 开发环境 和 生产环境 的，也就是 src 文件是我们的 开发环境 的项目代码文件夹，dist 文件夹是打包后自己生成的，不需要我们自己去创建。把 index.html 文件放在 src 目录下面，删除文件里面的 script 标签，html-webpack-plugin 会自动帮我们加入引入js的script标签。 1npm i -D html-webpack-plugin 项目中的配置 123456789101112//webpack.config.jsconst htmlPlugin = require('html-webpack-plugin')plugins: [ new htmlPlugin(&#123; minify: &#123; removeAttributeQuotes: true,//去掉标签中的引号 &#125;, hash: true, //引用js时有缓存，加上hash后每次都会给个不同的字符串。 template:'./src/index.html' &#125;) ], 打包后发现自动的新建了 dist 文件夹和里面的打包文件。 这里注意配置的写法，大括号太多。我写错了导致打包后的文件异常，找了半天问题 (⊙﹏⊙)b。 项目中引入图片css中引入图片eg:123456/* src/css/index.css */#img&#123; background-image:url(../img/img.png); width:120px; height:101px;&#125; 首先需要安装 url-loader 这个插件配置 webpack.config.js 文件： 12345678910111213&#123; rules:[ &#123; test: /\.(png|jpg|gif)$/, use: [&#123; loader: 'url-loader', options: &#123; limit:5000, &#125; &#125;] &#125; ]&#125; 注意：loader是不需要引入的。 limit:5000 的意思是：图片大于5000字节,自动拷贝图片到 dist 文件，并且在 bundle.js 文件中（打包后的js文件）修改正确的路径（包含了 file-loader 的一些功能）。如果小于5000,会生成base64位格式的图片直接插入到js文件中,好处是减少了http请求。 HTML中引入图片webpack 官方是不建议我们在html中引入图片的，如果有这种需求，直接添加 image 标签引入图片，打包后发现，图片并没有被打包到 dist 文件夹下面，因为图片没有被依赖。eg: 12&lt;-- index.html --&gt;&lt;div&gt;&lt;image src="./img/img.png"/&gt; &lt;/div&gt; 解决这个问题需要装 html-withimg-loader插件，然后配置： 1234567//webpack.config.jsloaders: [ &#123; test: /\.(htm|html)$/i, loader: 'html-withimg-loader' &#125;] CSS样式分离和publickPath设置CSS样式分离一般项目中css文件都是直接打包进 bundle.js 文件中去的，这样可以减少 http 请求。但是在某些时候，我们不想把 css 文件打包进入 bundle.js 文件中，比如：一个项目全是靠css样式来布局，js代码非常少得情况下，项目总监要求把项目交给切图仔维护等需求。如何实现呢： 1npm i -D extract-text-webpack-plugin 123456//webpack.config.jsconst extractTextPlugin = require('extract-text-webpack-plugin')plugins:[ new extractTextPlugin("css/index.css") //把css文件放在服务器的根目录（这里是dist文件夹下），下的css文件夹中。] css loader 也需要做一些更改 1234567&#123; test: /\.css$/, use: extractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: &quot;css-loader&quot; &#125;)&#125; publickPath设置打包代码，跑本地服务器，这时候发现图片没有了，查看打包后的项目结构，发现css文件中的路径有问题。 这时候需要设置 publiPath 公用路径，解决静态文件的路径问题。 12345678//webpack.config.jsvar website = &#123; publicPath:'http://192.168.1.105:1717/' //注意这里的斜杠，ip为服务器ip（在这里是你的计算机ip）&#125;output: &#123; ... publicPath:website.publicPath&#125; 重新打包，css文件中图片的路径变为了正确的绝对路径。 打包和分离LESS打包LESS文件到 bundle.js 文件中首先需要安装 less 、 less-loader 这两个包1npm i -D less less-loader webpack.config.js 配置 12345678910111213141516// webpack.config.jsmodule.exports = &#123; ... module: &#123; rules: [&#123; test: /\.less$/, use: [&#123; loader: "style-loader" // creates style nodes from JS strings &#125;, &#123; loader: "css-loader" // translates CSS into CommonJS &#125;, &#123; loader: "less-loader" // compiles Less to CSS &#125;] &#125;] &#125;&#125;; 注意loaderde顺序，顺序错误会造成打包失败的情况。 然后编写LESS文件，引入到入口JS文件中，就可以了。 分离LESS文件和分离css文件类似，需要用到 extract-text-webpack-plugin 这个包，上面已经安装了，这里不需要安装了。 12345678910111213141516//webpack.config.js const extractTextPlugin = require('extract-text-webpack-plugin')&#123; test: /\.less$/, use: extractTextPlugin.extract(&#123; use: [ &#123; loader: 'css-loader' &#125;, &#123; loader: 'less-loader' &#125; ], fallback:'style-loader' &#125;)&#125;plugins: [ new extractTextPlugin("css/index.css")] 打包后会把LESS中的样式转换成CSS样式，并且打包进index.css 文件中去，这里并不会新建一个CSS文件。 SASS的打包和分离SASS的打包将SASS转换成CSS，并且打包进bundle.js文件中去： 1npm i -D node-sass sass-loader 123456789//webpack.config.js&#123; test: /\.scss$/, //注意这里的 SCSS，不是SASS use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader' &#125;, &#123; loader: 'sass-loader' &#125; ]&#125; 在项目中引入打包就可以了。 SASS的分离和LESS分离步骤几乎一样 12345678910111213141516//webpack.config.js const extractTextPlugin = require('extract-text-webpack-plugin')&#123; test: /\.scss$/, use: extractTextPlugin.extract(&#123; use: [ &#123; loader: 'css-loader' &#125;, &#123; loader: 'sass-loader' &#125; ], fallback:'style-loader' &#125;)&#125;plugins: [ new extractTextPlugin("css/index.css")] 自动添加CSS属性前缀1npm i -D postcss-loader autoprefixer 需要再项目的根目录新建 postcss.config.js 配置文件。 123456//postcss.config.jsmodule.exports = &#123; plugins: [ require('autoprefixer') ]&#125; 1234567891011//webpack.config.js&#123;test: /\.css$/,use: extractTextPlugin.extract(&#123; fallback: "style-loader", use: [ &#123; loader: 'css-loader' &#125;, &#123; loader: 'postcss-loader' &#125; //here ]&#125;)&#125; 更多的配置参考 postcss-loader 分离多余的CSS样式有些时候css样式有多余的情况，比如使用 Bootstrap 这个库文件一小部分样式，或者项目几次改版产生了很多无效的CSS样式，这种情况下需要去除掉多余的CSS样式，以节省带宽。安装webpack插件 :1npm i -D purifycss-webpack purify-css 配置选项： 12345678910//webpack.config.jsconst glob = require('glob');const purifyCssPlugin = require('purifycss-webpack')const extractTextPlugin = require('extract-text-webpack-plugin')plugin:[ ..., new purifyCssPlugin(&#123; paths:glob.sync(path.join(__dirname,'src/*.html')) &#125;)] 这样就实现了多余代码的去除，好像是需要结合 CSS分离（extract-text-webpack-plugin）技术，才能实现代码的去除。自己测试过程：把CSS分离去除后，也就是让CSS代码打包进 bundle.js 文件里面，配置好代码，打包后没有去除掉多余的CSS文件，在 bundle.js 文件里面还能找到样式。 使用Babel转换ES6和ES7语法首先需要安装插件，我是结合 React 项目来使用 ES6 ES7 的，所以需要安装 babel-preset-react 来解析 React 的 jsx 语法。1npm i -D babel-core babel-loader babel-preset-env babel-preset-react 12345678910111213//webpack.config.js&#123; test: /\.(js|jsx)$/, use: [ &#123; loader: 'babel-loader' , //options:&#123; 这里注意实际中不会这样配置，一般新建.babelrc文件来写这些配置项 // presets:["env","react"] //&#125; &#125; ], exclude: /node_modules/ //不需要转换node_modules下的js文件&#125; 实际开发中 babel 的配置代码会越来越多，不建议在 use 中写 babel 的配置选项，而是在项目的根目录新建 .babelrc 配置文件。 1234//.babelrc&#123; "presets": ["react","env"] //渲染器&#125; 打包后的代码调试打包有四种模式： source-map : 打包速度最慢，最详细，生成了一个 .map的独立的文件,放在 dist 打包目录下，可以与打包后的文件很好的结合，报错信息包括 行 和 列。 cheap-module-source-map : 也生成独立文件，报错信息包括 行 和 不包括列，比上面的模式快。 eval-source-map : 不生成独立文件,报错信息包括 行 和 列，直接在 bundle.js 文件中生成 map, 速度也很快，有安全和性能的隐患，只能在开发阶段使用，上线前一定要删除 devtool:&#39;eval-source-map&#39;。 cheap-module-eval-source-map :不生成独立文件, 报错信息包括 行 和 不包括列列， 123456789//webpack.config.jsmodule.exports = &#123; devtool:'source-map', //here entry: &#123;&#125;, output: &#123;&#125;, module: &#123;&#125;, plugins: [], devServer: &#123;&#125;&#125; 参考教程]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native笔记本]]></title>
    <url>%2F2018%2F09%2F25%2Freact-native%E7%AC%94%E8%AE%B0%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[android App跳转到设置页面如何原生模块实现? Stack Overflow android 设置 常量列表 android App，设置禁止横屏。 AndroidManifest.xml 文件中的 &lt;activity&gt; 标签内添加 android:screenOrientation=&quot;portrait&quot; ios android 设置App 名称 ios : 在 Info.plist中修改 Android : android\app\src\main\res\values\strings.xml 文件中修改 &lt;string name=&quot;app_name&quot;&gt;MyProject&lt;/string&gt; ios android 设置icon图标 ios: 首先在这里 上传你的图标，注意：四个圆角边要透明的，如果是白色的在安卓上可能显示出来。 然后直接 project/ios/project_name/images.xcassets/ 直接替换。 android: 直接替换掉 project/android/app/src/main/res 里面的文件夹。 ios android 设置启动图 ios: 使用图片工具 App Icon Gear 来生成不同尺寸的图片 之后 参考 注意： android: 使用 react-native-splash-screen 来实现。 可以使用 这里 来生成android 的图片，注意生成后,每个文件夹里面的每张图名称需要更改为 launch_screen 然后配置 react-native-splash-screen ，就可以使用的了。 碰到的坑：按照文档配好后，出现ios 正常 ，android启动闪退, “Unfortunately, app has stopped”, 解决办法 解决TextInput 框点击空白处不失去焦点问题 在 TextInput 最外层的根节点加一个 ScrollView ,添加 keyboardShouldPersistTaps={‘never’}。 或者在最外层添加 TouchableOpacity 1234567891011121314151617import dismissKeyboard from 'dismissKeyboard'dismissKeyboardClick = () =&gt; &#123; dismissKeyboard() &#125;render()&#123; return （ ... &lt;TouchableOpacity style=&#123;&#123; flex: 1 &#125;&#125; onPress=&#123;this.dismissKeyboardClick&#125; activeOpacity=&#123;1&#125; &gt; //TextInput组件 &lt;TouchableOpacity/&gt; ...） &#125; react-native webview 如何引入本地html文件 ios : 直接 source={require(&#39;../../assets/html/message.html&#39;)} android : Android 需要先把静态资源放到 android/app/src/main/assets 目录下面，然后把 require(&#39;../../assets/html/message.html&#39;) 换成 {uri: &#39;file:///android_asset/html/message.html&#39;}。 解决 android 绝对定位元素定位在底部被键盘顶起问题 如果希望被顶起：android:windowSoftInputMode=&quot;adjustResize&quot; TextInput 组件设置 value 值不显示的问题value 值类型为字符串，设置成Number 类型不显示]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js代码片段难点集合]]></title>
    <url>%2F2018%2F09%2F25%2Fjs%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E9%9A%BE%E7%82%B9%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[如何理解12345function test(a,b,c) &#123; var _args = [].slice.call(arguments); console.log(_args)&#125;test(1,2,3) 如何封装一个柯里化通用式思路柯里化运行的过程是一个参数收集过程，并在最里面处理 12345678910111213141516171819// 简单实现，参数只能从右到左传递function createCurry(func, args) &#123; var arity = func.length; var args = args || []; return function() &#123; var _args = [].slice.call(arguments); [].push.apply(_args, args); // 如果参数个数小于最初的func.length，则递归调用，继续收集参数 if (_args.length &lt; arity) &#123; return createCurry.call(this, func, _args); &#125; // 参数收集完毕，则执行func return func.apply(this, _args); &#125;&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax跨域解决思路]]></title>
    <url>%2F2018%2F09%2F25%2Fajax%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[为什么会发生AJAX跨域？浏览器限制当浏览器发现请求是跨域的时候，它会做一些校验，如果校验不通过它就会报跨域安全错误。 跨域发出去的请求，协议、端口、请求地址，任何一个不一样，浏览器就会认为是跨域。 发送的是 XHR(XMLHttpRequest) 请求如果发送的不是XHR请求，就算是跨域，浏览器也不会报错。 解决问题的思路1.浏览器限制，我们就解除浏览器的跨域限制，从命令行中启动chrome。 open -n /Applications/Google\ Chrome.app/ --args --disable-web-security --user-data-dir=/Users/wenxiangye/MyChromeDevUserData/ 2.JSONP如何解决跨域问题？利用JQ实现JSONP请求 123456789$.ajax(&#123; url: base+"/get1", dataType: "jsonp", jsonp: "callback2", //默认不写前后端约定的名称是 callback cache: true, //表示结果可以被缓存，jsonp请求url中不会带 `_`字段 success: function(json)&#123; result = json; &#125;&#125;) 有三个不同点: 请求的Type不同 请求返回的 Content-Type 不同 JSON请求的URL后面自动加了callback 动态创建&lt;script&gt;标签，请求的资源可以跨域，来解决跨域问题的（eg：&lt;img&gt;标签中请求图片的地址可以跨域）后台代码也需要做处理，因为后台代码返回的是JSON，而通过JSONP请求的是JS文件，浏览器会把后台返回的JSON字符串当成是JS来解析，所以报错了。后台代码需要做的调整就是：请求参数中发现callback 这个字段，需要返回JS代码，callback 后面的值作为函数名，而请求需要返回的参数，作为函数的参数。 动态创建的script请求完毕后会被销毁，所以dom结构中无法查看，需要再JQ源码中9816行出打断点查看。 jsonp请求里面除了callback参数之外还多了一个_参数，参数值是一个随机的数字，防止请求被缓存。 JSON弊端： 服务器需要做一些改动。 只支持GET 发送的不是XHR请求，（XHR有很多新的特性，比如异步。） 3.被调用方解决跨域问题响应头增加字段，告诉浏览器允许跨域。浏览器发现请求是跨域的时候，他会在请求头增加当前域的字段Origin: http://localhost:8081 等请求返回来，他会检查响应头里面的字段信息，是否允许跨域。后端需要在响应头增加 ：Access-Control-Allow-Origin:http://localhost:8081Access-Control-Allow-Methods:GET两个字段都可以填写*表示所有域名和请求都可以跨域 简单请求和非简单请求浏览器在发送跨域请求的时候，会先判断跨域是简单请求还是非简单请求，如果是简单请求它会先执行，后判断。如果是非简单请求，会发一个OPTIONS的预检命令，检查通过后，他会把真正的请求发送过去。 简单请求的定义：方法为GET POST HEAD 、无自定义头部、Content-Type为：text/plain、multipart/form-data、application/x-www-form-urlencoded 三种。 非简单请求：方法为 PUT, DELETE 方法的ajax请求、发送json格式的ajax请求、带自定义头的请求 非简单请求时，如果跨域了，浏览器首先发送一个OPTIONS预检请求，在预检请求中会有一个字段 Access-Control-Request-Method: content-type ，询问后台服务器是否允许 content-type 这个头，如果响应头部没有通过的信息，就会报跨域的错误。 解决方法： 后台代码需要增加头信息 Access-Control-Allow-Headers: Content-Type 非简单请求每个跨域请求都会请求两次，这样非常影响效率，响应可以增加一个头信息，来缓存预检命令，Access-Control-Max-Age: 3600 这个头信息的意思是告诉浏览器，在3600秒内，可以缓存预检命令的结果，不需要发送预检命令。 带cookie的跨域：当响应头Access-Control-Allow-Origin: * 时，是不能满足带cookie的跨域请求的，前端设置 ： 1234567$.aiax(&#123; ..., xhrFields:&#123; withCredentials:true &#125; ...&#125;) 后端设置头信息 Axxess-Control-Allow-Origin: http://localhost:8081和Access-Control-Allow-Credentials: true 但是这样做之后，浏览器只会允许 http://localhost:8081 这个地址来跨域，如果需要多个地址请求实现跨域如何实现呢？之前知识点： 浏览器发现请求是跨域的时候，他会在请求头增加当前域的字段Origin: http://localhost:8081 等请求返回来，他会检查响应头里面的字段信息，是否允许跨域。后端可以动态的去取 Origin这个字段的值，如果不为空，则 Axxess-Control-Allow-Origin: Origin,现在就可以支持任何的跨域调用了。 带自定头的跨域首先前端定义： 可以发现请求头部增加了如下内容： 此时去请求发现报错报错信息的意思是：在返回头Access-Control-Allow-Headers 字段中没有 x-header2 的信息，把 x-header1 x-header2 加进去就行了，最好是动态的获取请求头Origin里面的值去添加，这样就支持所有的自定义头部了。 虚拟主机上设置响应头信息之前我们是直接在应用服务器上面修改响应头信息，现在我们建立一个虚拟主机，在虚拟主机上面修改响应头信息被调用方的虚拟主机的配置。 第一步首先配置HOST文件eg: 1127.0.0.1 b.com 打开nginx中的config目录 新建一个 vhost目录，在里面新建虚拟主机的配置文件。打开 nginx.config 文件,在最后增加 1include vhost/*.conf //让nginx载入这个目录下的所有.conf文件 在vhost目录中新建一个 b.com.config文件，里面写入下面代码 12345678910111213141516server&#123; listen 80; //监听的端口 server_name b.com; //监听的域名 location /&#123; proxy_pass http://localhost:8080/; //把所有的请求都转到 8080,监听80端口，域名为b.com add_header Access-Control-Allow-Methods *; add_header Access-Control-Max-Age 3600; add_header Access-Control-Allow-Credentials true; add_header Access-Control-Allow-Origin $http_origin; //获取请求头里面的值 add_header Access-Control-Allow-Headers $http_access_control_request_headers; if ($request_method = OPTIONS)&#123; return 200; //把跨域的预检命令直接在虚拟主机上处理，不经过应用主机。 &#125; &#125;&#125; 启动nginx start nginx 调用方解决跨域通过反向代理来实现,隐藏跨域。 正向代理：它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求。 反向代理:它隐藏了真实的服务端，当我们请求 www.baidu.com 的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，www.baidu.com 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。 两者的区别在于代理的对象不一样：正向代理代理的对象是客户端，反向代理代理的对象是服务端。摘自知乎-刘志军的回答 1127.0.0.1 b.com a.com //增加一个a.com，用它表示调用方的虚拟主机 在vhost目录中新建一个 a.com.config文件，里面写入下面代码 123456789101112server &#123; listen 80: server_name a.com; location /&#123; proxy_pass http://localhost:8081/; &#125; location /ajaxserver&#123; //把我们要调用的服务器代理成 ajaxserver proxy_pass http://localhost:8080/test/; &#125;&#125; 请求的代码中修改请求的基本前缀 1var base = '/ajaxserver';]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-redux_使用装饰器优化connect代码]]></title>
    <url>%2F2018%2F09%2F24%2Freact-redux-%E4%BD%BF%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8%E4%BC%98%E5%8C%96connect%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[项目是使用 create-react-app 创建 npm run eject弹出个性化配置 npm i babel-plugin-transform-decorators-legacy 插件 package.json里babel加上plugins配置]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMD-CMD-CommonJs和ES6对比]]></title>
    <url>%2F2018%2F09%2F24%2FAMD-CMD-CommonJs%E5%92%8CES6%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[AMDAMD 是 RequireJS在推广过程中对模块定义的规范化产出,推崇依赖前置。 12345678define(['package/lib'],fucntion(lib)&#123; function()&#123; lib.log('hello world!') &#125; return &#123; foo: foo &#125;&#125;) 优点：代码一旦运行到此处，能立即知晓依赖。而无需遍历整个函数体找到它的依赖，因此性能有所提升。加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。缺点：就是开发者必须显式得指明依赖——这会使得开发工作量变大，比如：当你写到函数体内部几百上千行的时候，忽然发现需要增加一个依赖，你不得不回到函数顶端来将这个依赖添加进数组。 CMDCMD是SeaJS在推广过程中对模块定义规范化产出，推崇依赖就近。 123456//所有模块通过 define定义define(function(require, exports. module)&#123; //通过 require 引入依赖 var $ = require(&apos;jquery&apos;) var Spinning = require(&apos;./spinning&apos;)&#125;) CommonJS是node服务端的一个规范,只在服务端使用，浏览器并不支持。 123export.area = function(r)&#123; return Math.PI * r * r;&#125; ES6 export/import]]></content>
      <tags>
        <tag>模块化规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa笔记]]></title>
    <url>%2F2018%2F09%2F24%2Fkoa%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Context对象Koa提供一个Context对象，表示一次对话的上下文（包括HTTP请求和HTTP回复），通过给这个对象赋值可以控制返回给用户的内容。 eg: 12345678const Koa = require('koa');const app = new Koa();const main = ctx =&gt; &#123; ctx.response.body = 'Hello World';&#125;;app.use(main);app.listen(3000); 给响应的body 添加内容Koa默认返回的类型是 text/plain。可以使用 ctx.request.accepts(&#39;json&#39;) 来判断客户端接收什么数据，同时设置返回的类型 ctx.response.type = &#39;json&#39;。 1234ctx.response.body = 'Hello World'; //textctx.response.body = &#123; data: 'Hello World' &#125;; //jsonctx.response.body = '&lt;p&gt;Hello World&lt;/p&gt;'; //htmlctx.response.body = '&lt;data&gt;Hello World&lt;/data&gt;'; //xml 网页模板Koa先读取模板文件，然后返回给用户 1ctx.response.body = fs.createReadStream('./demos/template.html'); 路由原生路由是通过 ctx.request.path 可以获取用户请求的路径,由此判断该返回什么内容给用户，使用不方便，一般使用 koa-route. 12345const about = ctx =&gt; &#123; ctx.response.type = 'html'; ctx.response.body = '&lt;a href="/"&gt;Index Page&lt;/a&gt;';&#125;;app.use(route.get('/about', about)); 静态资源如果服务器需要返回给用户一些静态资源（图片，字体，样式表，脚本），一个个写路由很麻烦，可以使用 koa-static 。 1234567const Koa = require(&apos;koa&apos;);const app = new Koa();const path = require(&apos;path&apos;);const server = require(&apos;koa-static&apos;)const publicServer = server(path.join(__dirname) + &apos;/public&apos;);app.use(publicServer);app.listen(3000); 这样用户可以访问 __dirname 文件夹下的所有文件。eg:输入http://localhost:3000/01.js ，可以查看 __dirname 文件夹下的 01.js 文件。 路由重定向ctx.response.redirect(&#39;/&#39;) 方法可以发出一个302跳转,将用户导向另一个路由。 中间件Koa最重要的一个设计就是中间件，比如打印日志中间件简单的写法，可以直接main函数中写 console.log(...)， 也可以拆分成一个独立函数（如下） 12345678910const logger = (ctx, next) =&gt; &#123; console.log(`$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); next();&#125;const main = ctx =&gt; &#123; ctx.response.body = 'Hello World';&#125;;app.use(logger);app.use(main);app.listen(3000); 上面的代码 logger 函数就叫 中间件。 中间件：处于 HTTP Request 和 HTTP Response 中间，用来实现某种中间功能， app.use() 用来加载中间件。 中间件默认有两个参数，(Context, next), 只要调用 next() 就把执行权交给下一个中间件。 123456789101112131415161718const one = (ctx, next) =&gt; &#123; console.log('&gt;&gt; one'); next(); console.log('&lt;&lt; one');&#125;const two = (ctx, next) =&gt; &#123; console.log('&gt;&gt; two'); next(); console.log('&lt;&lt; two');&#125;const three = (ctx, next) =&gt; &#123; console.log('&gt;&gt; three'); next(); console.log('&lt;&lt; three');&#125;app.use(one);app.use(two);app.use(three); 三个中间件: one中间件 、 two中间件 、 three中间件。执行步骤 ：最外层 one 首先执行,调用next()方法后,next()方法后面的代码并不会执行,而是把执行权交给下一个中间件 two,同理交给 three 。我的理解是：next() 后面的代码被放入了任务队列，当主线程也就是 next() 之上的代码执行完毕后，执行任务队列的代码，任务队列里面的代码以 先进后出 的顺序执行。 如果删除 two 中间件函数中的 next() ,执行权并不会交给 three 中间件，也就是说 three并不会被执行。 异步中间件12345const fs = require('fs.promised');const main = async function (ctx, next) &#123; ctx.response.type = 'html'; ctx.response.body = await fs.readFile('./demos/template.html', 'utf8');&#125;; 中间件合成 koa-compose1234567891011const compose = require('koa-compose')const logger = (ctx, next) =&gt; &#123; console.log(ctx); next()&#125;const main = ctx =&gt; &#123; ctx.response.body = 'Hello World'&#125;const middlewares = compose([logger, main])app.use(middlewares) 错误处理如果代码运行过程中发生错误，我们需要把错误信息返回给用户，可以使用 ctx.throw(statusCode) 来返回, ctx.response.status = 404 等价于 ctx.throw(404) 。 为了方便处理错误，最好使用 try...catch, 每个中间件写太麻烦，可以让最外层的中间件负责所有处理 123456789101112131415const handler = async (ctx, next) =&gt; &#123; try &#123; await next(); &#125; catch (err) &#123; ctx.response.status = err.statusCode || err.status || 500; ctx.response.body = &#123; message: err.message &#125;; &#125;&#125;;const main = ctx =&gt; &#123; ctx.throw(500);&#125;;app.use(handler);app.use(main); 以上代码，由于 main中间件中抛出了错误，会执行 最外层中间件handler catch里面的代码。 错误事件监听代码运行过程中出错，Koa会触发一个 error 事件。 1234//错误事件监听app.on('error', (err, ctx) =&gt; console.error('server error', err);); 如果错误被 try...catch 捕获， 就不会触发error事件，必须调用 ctx.app.emit() 手动释放 error 事件，才能让监听函数生效。 12345678const handler = async (ctx, next) =&gt; &#123; try &#123; await next(); &#125; catch (err) &#123; //... ctx.app.emit('error', err, ctx); &#125;&#125; 读写 cookies1234const main = ctx =&gt; &#123; ctx.cookies.get('view'); ctx.cookies.set('view', n);&#125; koa-body 提取键值对他可以用来提取POST请求体中的键值对,类似于 name=Jack 1234567891011const koaBody = require(&apos;koa-body&apos;);const app = new Koa();const main = async function(ctx) &#123; const body = ctx.request.body; console.log(body) if (!body.name) ctx.throw(400, &apos;.name required&apos;); ctx.body = &#123; name: body.name &#125;;&#125;;app.use(koaBody());app.use(main); 获取GET请求中的查询参数 ctx.request.query ctx.query koa-view使用1234567891011const views = require(&apos;koa-views&apos;)const &#123; resolve &#125; = require(&apos;path&apos;)app.use(views(resolve(__dirname, &apos;./views&apos;),&#123; extension:pug&#125;)app.use(async (ctx, next) =&gt; &#123; await ctx.render(&apos;index&apos;,&#123; title:&apos;ye&apos; &#125;)&#125;)]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[媒介查询]]></title>
    <url>%2F2018%2F09%2F24%2F%E5%AA%92%E4%BB%8B%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[使用CSS3的 Media Query 查询1.外链方式 1&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;link.css&quot; media=&quot;only screen and (max-width:480px)&quot;/&gt; 只有当屏幕宽度 &lt;= 480px 时，才会加载这个CSS文件。 2.内嵌方式 12345@media screen and (min-width: 480px)&#123; body&#123; background:blue; &#125;&#125; 当屏幕宽度 &gt;= 480 时 body 背景为蓝色。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx笔记]]></title>
    <url>%2F2018%2F09%2F24%2Fnginx%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[客户端nginx路径信息配置文件路径: /usr/local/etc/nginx/nginx.conf服务器默认路径: /usr/local/var/www安装路径: /usr/local/Cellar/nginx/1.13.9 启动直接终端输入 nginx 启动，可以使用 ps -ef|grep nginx 来查看是否启动成功进程号为 3843在终端输入 kill -term 3843 来停止进程 重启12nginx -s reloadservice nginx reload #不停服务重启 查找配置文件路径mac下使用homebrew 安装 nginx 的路径：/usr/local/etc/nginx/nginx.conf1ps -ef | grep nginx 403 Forbidden权限问题解决12sudo chown -R $USER:$USER /root/www/blogsudo chmod -R 755 /root/www]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端常用CSS代码]]></title>
    <url>%2F2018%2F09%2F24%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E7%94%A8CSS%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1px边框问题使用123456789101112131415161718.xx&#123; position:relative;&#125;.xx:before&#123; content:''; position: absolute; top: 0; left: 0; border: 1px solid #ccc; width: 200%; height: 200%; box-sizing:border-box; -webkit-box-sizing:border-box; -webkit-transform: scale(0.5); transform: scale(0.5); -webkit-transform-origin: left top; transform-origin: left top;&#125; 背景图裁切123456.xx&#123; background-image:url('...'); background-position:center center; background-size:cover; background-repeat:no-repeat;&#125; 横向滚动1234567.parent&#123; display: -webkit-box; overflow-x: scroll; overflow-y: hidden; -webkit-overflow-scrolling: touch; /* 弹性滑动 */&#125; 单行显示，超过省略号12345.xx&#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125; 两行显示，超过省略号1234567.xx&#123; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;&#125; 防止ios手机降页面数字变成蓝色号码1&lt;meta name="format-detection" content="telephone=no" /&gt; 静止手机用户缩放1&lt;meta charset="utf-8" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" /&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>移动端常用CSS代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node异步编程方案]]></title>
    <url>%2F2018%2F09%2F24%2Fnode%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[回调函数 (第一阶段)123456789101112function readFile (cb)&#123; fs.readFile(path, (err, data) =&gt; &#123; if (err) console.log(err) else console.log(data) &#125;)&#125;readFile((err, data) =&gt; &#123; if(!err)&#123; data = JSON.parse(data) console.log(data.value) &#125;&#125;) promise (第二阶段)12345678910111213141516function readFileAsync(path) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(path, (err, data) =&gt; &#123; if (err) reject(err) else resolve(data) &#125;) &#125;)&#125;readFileAsync('./package.json') .then(data =&gt; &#123; data =JSON.parse(data) console.log(data) &#125;) .catch(err=&gt;&#123; console.log(err) &#125;) 通过utli.promisify() 方法包装只能传递一个异步回调函数，返回一个promise Function,第二个括号为传递的参数 123456789101112const utli = require('util')utli.promisify(fs.readFile)('./package.json') .then(data =&gt; &#123; return JSON.parse(data) &#125;) .then(data =&gt; &#123; console.log(data.name) &#125;) .catch(err=&gt;&#123; console.log(err) &#125;) 结合使用 async await1234567891011const readAsync = utli.promisify(fs.readFile)async function init ()&#123; try&#123; let data = await readAsync('./package.json') data = JSON.parse(data) console.log(data.name) &#125; catch(err)&#123; console.log(err) &#125;&#125;init() Generator其本质是一个迭代器，下面来实现一个类似的迭代器 12345678910111213141516function makeIterator (arr)&#123; let nextIndex = 0 //返回一个迭代器对象 return &#123; next: () =&gt; &#123; if(nextIndex &lt; arr.length)&#123; return &#123;value: arr[nextIndex++], done: false&#125; &#125; else &#123; return &#123;done: true&#125; &#125; &#125; &#125;&#125;const it = makeIterator(['吃饭', '睡觉'])console.log(it.next().value) //吃饭console.log(it.next().value) //睡觉 生成器（Generator）：返回迭代器的函数,简化自己创建迭代器繁琐的过程，同时保持逻辑的清晰性。 12345678funciton *makeIterator (arr)&#123; for(let i = 0; i &lt; arr.length; i++)&#123; yield arr[i] &#125;&#125;const gen = makeIterator(['吃饭', '睡觉'])console.log(gen.next().value) //吃饭console.log(gen.next().value) //睡觉 co 与 Generator (第三阶段)12345678const co = require('co')const fetch = require('node-fetch')co(function *()&#123; const res = yield fetch('https://api.douban.com/v2/movie/1291843') const movie = yield res.json() const summary = movie.summary console.log(summary)&#125;) 通过co 这个库，可以传递一个Generator函数,就可以通过同步的方式，来执行异步的过程。通过 yield 关键字可以实现一个状态的暂停，当 yield后面的异步代码没有执行完毕时，后面的代码不会执行。简单来说co 函数能让里面 yield 暂停的函数都能得到一步步的执行，实现了 Generator 的自动执行 async Function （第四阶段 统一世界）123456const = readAsync = utli.promisify(fs.readFile)async function init ()&#123; let data = await readAsync('./package.json') data = JSON.parse(data) console.log(data.name)&#125;]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoDB操作]]></title>
    <url>%2F2018%2F09%2F24%2FmongoDB%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[创建12&gt; post = &#123;"title": "my blog post", "content":"here's my blog post", "date": new Date()&#125;&gt; db.blog.insert(post) javascript shell 中， db 命令现当前所在的数据库，上面代码，在当前数据库中的 blog集合 插入 post文档。可以使用 db.blog.find() 查找 blog 集合中保存的所有文档。 读取find(): 会返回集合里面所有的文档，若只想查看一个文档可以使用 findOne 1&gt; db.blog.findOne() 更新update: 接收至少两个参数: 第一个是更新文档的限定条件 第二个是新文档 第三个参数为true时，表示开启 upsert 更新模式，要是没有文档符合更新条件，就会以这个条件和更新文档为基础创建一个新文档，如果找到则正常更新。 第四个参数为true时，表示开启多文档更新，默认为false，只能匹配并更新一个。 比如给上面的文档增加一个 comments 字段，值为[] 12&gt; post.comments = []&gt; db.blog.update(&#123;title:&quot;my blog post&quot;&#125;, post) 例子：删除数据库集合中某个字段 1db.User.update(&#123;&#125;,&#123;$unset:&#123;&apos;address&apos;:&apos;&apos;&#125;&#125;,false, true) 使用修改器利用原子的 更新修改器，使得这部分修改极为高效。比如页面访问统计 12345&#123; "_id" : ObjectId("5b430d4da1d1ea0fd260cae5"), "url" : "www.baidu.com", "pageviews" : 52&#125; 12&gt; db.blog.update(&#123;"url":"www.baidu.com"&#125;, &#123;"$inc":&#123;"pageviews":1&#125;&#125;)# 会将上面的pageviews + 1， 如果update 第一个参数匹配到多个文档，只会更新第一个,所以一般选择ID作为条件 “$set”修饰器用来指定一个键的值，如果这个键不存在则创建。（更新键的值，或者数据类型。） 1&gt; db.blog.update(&#123;"_id":ObjectId("5b431136a1d1ea0fd260cc3e")&#125;, &#123;"$set":&#123;"favorite book": "war and peace"&#125;&#125;) 可以修改类型: 1&gt; db.blog.update(&#123;"_id":ObjectId("5b431136a1d1ea0fd260cc3e")&#125;, &#123;"$set":&#123;"favorite book": ["cat", "dog"]&#125;&#125;) 修改嵌套文档 “$unset”修饰器将一个键完全删除 1&gt; db.blog.update(&#123;"_id":ObjectId("5b431136a1d1ea0fd260cc3e")&#125;, &#123;"unset": &#123;"favorite book": 1&#125;&#125;) “$inc”修饰器用来增加已有键的值，或者在键不存在时创建一个键。 12&gt; db.blog.update(&#123;"game":"pinball","user":"joe"&#125;,&#123;"$inc":&#123;"score":50&#125;&#125;)# 每次增加50,可以为负值 “$inc” 专门用来增加和减少数字的，只能用于整数、长整数或双精度浮点数 数组修改器“$push” 会向已有的数组末尾加入一个元素，要是没有就创建一个新的数组。 情景：值不在数组中时，把它加进去，可以在查询文档中使用 “$ne” 来实现。 1&gt; db.blog.update(&#123;"authords cited": &#123;"$ne": "Richie"&#125;, &#123;"$push": &#123;"authords cited": "Richie"&#125;&#125;&#125;) 也可以使用 “$addToSet” 完成同样的事情,向数组添加值，避免重复。 “$addToSet” 可以和 “$each” 结合使用，一次添加多个不同的值 1234567&gt; db.blog.update(&#123;"_id": ObjectId("5b431136a1d1ea0fd260cc3e")&#125;, &#123; "$addToSet":&#123; "emails" :&#123; "$each" : ["dsa@qq.com", "dsd3aa@qq.com", "dsd2a@qq.com"] &#125; &#125;&#125;) “$pop”修饰器1&#123;$pop: &#123;key:1&#125;&#125; //从数组末尾删除一个元素, key:-1 从头部删除 “$pull”修饰器“$pull” 可以特定条件来删除元素，不仅仅是依据位置。 123&gt; db.lists.insert(&#123;"todo": ["dishes", "laundry", "dry cleaning"]&#125;)&gt; db.lists.update(&#123;&#125;, &#123;"$pull": &#123;"todo":"laundry"&#125;&#125;)# 会删除数组中的laundry ,如果有多个，会全部删除。 数组的定位修改器假设文档中 comments 字段是一个数组，里面包含多个对象 12345&gt; db.blog.update(..., &#123;"$inc": &#123;"comments.0.votes":1&#125;&#125;)#增加第一个评论的投票数量&gt; db.blog.update(&#123;"comment.author": "John"&#125;, &#123;"$set": &#123;"comments.$.author": "Jim"&#125;&#125;)# $占位符，查询到评论中 作者名为John 的下标，更新为 Jim save函数save是一个shell函数,可以在文档不存在时插入，存在时更新，它只有一个参数：文档 如果这个文档含有”_id” 键，save会调用 upsert。否则会调用插入。 12345var x = db.foo.findOne()x.num = 42db.foo.save(x)# 免去了 update 的查询条件 删除remove: 从数据库永久删除文档，在传空对象调用，会删除一个集合内所有的文档 1&gt; db.blog.remove(&#123;title: &quot;my blog post&quot;&#125;) shell技巧12345&gt; db.help()# 查看数据库级别的入门命令&gt; db.foo.help()# 查看集合相关命令]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoose操作]]></title>
    <url>%2F2018%2F09%2F24%2Fmongoose%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[简单的 mongoose 示例1234567891011121314151617181920212223242526272829const mongoose = require('mongoose')mongoose.connect("mongodb://localhost:27017/study", &#123;useNewUrlParser:true&#125;, function(err)&#123; if(err)&#123; console.log('Connection Error:' + err) &#125;else&#123; console.log('Connection success!') &#125;&#125;)const UserSchema = new mongoose.Schema(&#123; nickname:&#123; type:String, default: 'new user' //在实例化 model 时，如果不传参则为默认值 &#125;&#125;)const User = mongoose.model('User', UserSchema)const user = new User(&#123; nickname:'ye'&#125;)// 保存到数据库user.save(err =&gt; &#123; if(err)&#123; return console.log(err) &#125; console.log(user.nickname) //打印保存后的值&#125;) 预定义修饰符 自定义：set修饰符 get修饰符 model 第二个参数会被直接传给 new mongoose.Schema 1234567891011121314151617181920212223const User = mongoose.model('User', &#123; nickname:&#123; type:String, trim: true //预定义修饰符 &#125;, blog:&#123; type:String, set:v =&gt; &#123; //自定义：set修饰符, new modal 传入的参数时执行 if(!v) return v; if(0 !== v.indexOf('http://') &amp;&amp; 0 !== v.indexOf('https://'))&#123; v = `http://$&#123;v&#125;` return v &#125; &#125;, get:v =&gt; &#123; //自定义：get修饰符, 数据存入数据库之后，取值时执行 if(!v) return v; if(0 !== v.indexOf('http://') &amp;&amp; 0 !== v.indexOf('https://'))&#123; v = `http://$&#123;v&#125;` return v &#125; &#125; &#125;&#125;) 虚拟属性有时我们不需要把值存取到数据库，可以通过其他的属性值计算，得到我们需要的值，这时可以利用到虚拟属性。 123456789101112131415const PersonSchema = new mongoose.Schema(&#123; firstName:String, lastName:String,&#125;)PersonSchema.virtual('fullName').get(function()&#123; return this.firstName + this.lastName&#125;)var Person = mongoose.model('Person', PersonSchema)var person = new Person(&#123; firstName:'ye', lastName:'wenxiang'&#125;)console.log(person.fullName) //yewenxiang 索引 唯一索引：检查是否唯一 辅助索引：增加查询速度 12345678910const BookSchema = new mongoose.Schema(&#123; isbn:&#123; type:Number, unique: true //唯一索引 &#125;, name:&#123; type: String, index: true, //辅助索引 &#125;&#125;) 模型的方法123456789101112// 自定义静态方法，在 BookSchema.findIsbn 上调用BookSchema.statics.findIsbn = function(isbn, cb)&#123; this.findOne(&#123;isbn&#125;, (err, doc)=&gt;&#123; cb(err, doc) &#125;)&#125;//自定义实例方法 在每个 new 出来的示例上调用BookSchema.methods.print = function()&#123; console.log(this.name) console.log(this.isbn)&#125; 数据校验数据在保存时检测是否符合规则。 预定义验证器 12345678910111213141516const orderSchema = new mongoose.Schema(&#123; count:&#123; type:Number, required: true, //必须传值 才能保存 max:1000, min:10, &#125;, status:&#123; type:String, enum:['created', 'success', 'failed'] //只能三个中选一个 才能保存 &#125;, dec:&#123; type:String, match: /Book/g, //正则验证，字符串中存在Book 才能保存 &#125;&#125;) 自定义验证器 12345678const orderSchema = new mongoose.Schema(&#123; desc: &#123; type:String, validate:(v) =&gt; &#123; return desc.length &gt;= 10 &#125; &#125;&#125;) 中间件 文档中间件：init/validate/save/remove 查询中间件：count/find/findOne/findOneAndRemove/findOneAndUpdate/update 集合交叉引用123456789101112131415161718192021222324252627282930313233343536373839404142const mongoose = require('mongoose');const Schema = mongoose.Schemaconst &#123;ObjectId, Mixed&#125; = Schema.Typesmongoose.connect("mongodb://localhost:27017/news", &#123;useNewUrlParser:true&#125;, function(err)&#123; if(err)&#123; console.log('Connection Error:' + err) &#125;else&#123; console.log('Connection success!') &#125;&#125;)const User = mongoose.model('User', &#123; user:String&#125;)const Artical = mongoose.model('Artical', &#123; title:String, author:&#123; type:ObjectId, ref:'User' &#125;&#125;)const user = new User(&#123; user:'ye'&#125;)const artical = new Artical(&#123; title: '标题', author: user&#125;)user.save(err=&gt;&#123; if(err) return console.log(err) console.log('user save success') artical.save(err =&gt; &#123; if(err) return console.log(err) console.log('artical save success') Artical.findOne(&#123;&#125;).populate('author').exec(function(err, doc)&#123; console.log(doc) &#125;) &#125;) &#125;)]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[puppeteer安装]]></title>
    <url>%2F2018%2F09%2F24%2Fpuppeteer%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[puppeteer 在执行安装的过程中需要执行install.js，这里会下载Chromium，翻墙也下载失败，导致安装不成功，官网建议是进行跳过，解决办法： 12&gt; npm i --save puppeteer --ignore-scripts#忽略 puppeteer js脚本的执行 手动下载 ChromiumChromium 下载 地址会根据系统来下载对应的 安装文件。 mac环境下载完毕后，把Chromium复制在项目的根目录 测试是否安装成功12345678910111213const puppeteer = require('puppeteer');(async () =&gt; &#123; const browser = await puppeteer.launch(&#123; executablePath: './chromium/Chromium.app/Contents/MacOS/Chromium', //自定义程序地址 &#125;); const page = await browser.newPage(); await page.goto('https://y.qq.com'); await page.screenshot(&#123;path:'yqq.png'&#125;); browser.close();&#125;)() puppeteer.launch 参数说明 executablePath：运行Chromium或Chrome可执行文件的路径 headless：true为不打开浏览器执行，浏览器运行在内存中，默认为true timeout： 等待浏览器实例启动的最长时间（以毫秒为单位）。默认为30000（30秒）。通过0禁用超时 args： 传递给浏览器实例的其他参数]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>puppeteer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 async 控制并发数量]]></title>
    <url>%2F2018%2F09%2F24%2Fasync%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344const eventproxy = require('eventproxy')const superagent = require('superagent')const cheerio = require('cheerio')const url = require('url')const async = require('async')const ep = new eventproxy()const cnodeUrl = 'https://cnodejs.org'const topicUrls = [];superagent.get(cnodeUrl) .end(function (err, res) &#123; if (err) &#123; return console.error(error) &#125; const topicUrls = []; const $ = cheerio.load(res.text); $('#topic_list .topic_title').each((index, item) =&gt; &#123; const href = url.resolve(cnodeUrl, $(item).attr('href')) topicUrls.push(href) &#125;) console.log(topicUrls.length) let count = 0; async.mapLimit(topicUrls, 6, function (url, callback) &#123; count++ console.log(`现在的并发数$&#123;count&#125;`) superagent.get(url) .end(function (err, res) &#123; if (err) return console.log(`fetch faild $&#123;err.status&#125;`) count-- callback(null, [url, res.text]) &#125;) &#125;, function (err, result) &#123; if (err) return console.log(err) result = result.map(item =&gt; &#123; const $ = cheerio.load(item[1]); return (&#123; title:$('.topic_full_title').text().trim(), url:item[0], comment1:$('.reply_content').eq(0).text().trim(), &#125;) &#125;) console.log(result) console.log(result.length) &#125;) &#125;)]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>async</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F09%2F24%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[语法介绍元字符 . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线或汉字 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 限定符 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 反义符 \W 匹配任意不是字母，数字，下划线，汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 参考 30分钟正则入门]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用命令]]></title>
    <url>%2F2018%2F09%2F24%2Fbash-command%2F</url>
    <content type="text"><![CDATA[升级react-native react-native-git-upgrade,直接升级到最新版本。升级到指定的版本 react-native-git-upgrade X.Y.Z。 升级时遇到的问题 ,删除掉 &quot;react-native-camera&quot;: &quot;git+https://github.com/lwansbrough/react-native-camera.git&quot;, 更新完成后，再安装 react-native-camera npm outdated 查看有哪些包可更新 npm-check -u 查看有哪些包可更新 npm list -g --depth 0 查看全局安装的包(depth 0 是只显示最顶层的包，不显示下面的依赖包) npm update 升级所有更新包,npm 2.6.1后才支持 yarn upgrade react-native-modalbox 升级包 which react-native 查看包的路径 mono --arch=32 Fiddler.exe 打开exe文件 lsof -i:端口号 kill -9 PID杀死进程 git 版本回滚 git reset --hard HEAD~0 forever start 你的脚本文件(如server.js) forever list 查看所有 forever 运行的进程 forever stop uid 停止运行指定 uid 的进程 control + D 断开 ssh 连接]]></content>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo相关]]></title>
    <url>%2F2018%2F09%2F24%2Fhexo%2F</url>
    <content type="text"><![CDATA[12hexo clean &amp;&amp; hexo generate --deploy #自动部署hexo g &amp;&amp; hexo d #部署到github]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
