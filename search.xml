<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack3.0+基础学习]]></title>
    <url>%2F2018%2F09%2F25%2Fwebpack3-0-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[一个webpack demo 首先是建立项目结构 根目录新建 src 文件夹 (开发环境时的代码) 根目录新建 dist 文件夹（生产环境的代码） webpack 打包的本质是把 src下的入口文件 entry.js 文件，及其相关联的文件,打包成bundle.js文件，并且放在 dist 文件夹下面 webpack 的打包命令： 如果是全局安装的webpack : $webpack src/entry.js dist/bundle.js。 如果是项目中安装的webpack : $./node_modules/.bin/webpack src/entry.js dist/bundle.js 一般我们webpack不会使用全局安装的方式，会造成版本冲突导致的问题。而使用项目中安装的webpack 命令行每次打包输入又太长，可以将命令行写进 package.json 文件里面的 script 标签中： 123"scripts": &#123; "bundle":"./node_modules/.bin/webpack src/entry.js dist/bundle.js" &#125;, 这样每次打包只需要 $npm run bundle 就可以了。 小技巧： bundle 改成 start ，只需要 npm start。全局安装 live-server 这个插件可以在本地跑一个服务器，使项目跑在 8080 这个端口。 webpack配置文件在项目的根目录新建 webpack.config.js 文件，配置的基本结构： 1234567module.exports = &#123; entry: &#123;&#125;, output: &#123;&#125;, module: &#123;&#125;, //模块解读css，打包css，图片转换压缩等配置。 plugins: [], //插件 devServer: &#123;&#125;, //配置开发服务&#125; 上面将入口出门配置信息写进了 script 脚本里面，然后使用 npm start 来跑这段脚本，也就是跑这段命令，这种方式来配置是非常单一的，没有更多的配置选项，如果做多入口多出口的配置就无法实现了。正确开发的姿势是将配置信息写进 webpack.config.js 文件中： 12345678910const path = require('path'); //注意引入 path 模块module.exports = &#123; entry: &#123; entry:'./src/entry.js' //入口文件路径 &#125;, output: &#123; path:path.resolve(__dirname,'dist'), //出口文件路径 filename:'bundle.js' //打包后的文件名 &#125;&#125; path.resolve(__dirname,&#39;dist&#39;) 代码解读： path：node核心模块之一,需要引入path 。 __dirname：当前文件所在目录的完整绝对路径。 resolve：resolve 会将参数中的路径或路径片段的序列解析为一个绝对路径，这样即使项目迁移，地址变更，只要保证相对路径正确即可。 代码解读：出口文件存放路径为当前文件夹下的 dist 文件夹中。 多入口 多出口 配置在 src 下新建一个 entry2.js 文件，也就是第二个入口文件，加入js代码，更改配置。12345678entry: &#123; //固定命名 entry: './src/entry.js', //这里的entry名字是自己定义的 entry2: './src/entry2.js', &#125;, output: &#123; path:path.resolve(__dirname,'dist'), filename:'[name].js' //[name] 打包的出口文件名 和 入口文件名是一样的 &#125;, 更改 dist/index.html 中引入的js文件，就可以查看效果了。 注意：两个入口肯定需要两个出口文件对应 服务和热更新自己配置一个本地的服务器，首先需要在项目中安装 webpack-dev-server 这个包。1npm i webpack-dev-server --save-dev shell 中输入命令 webpack-dev-server ，是无法识别的，因为没有全局安装，环境变量中也就没有存在命令所在的目录。我们需要再 package.json 中加入:1"server":"./node_modules/.bin/webpack-dev-server --open" 后面加上参数 --open 运行后直接弹出浏览器 这样配置后 npm run server 他会去找 webpack.config.js 文件中的服务器配置信息： 123456devServer: &#123; contentBase: path.resolve(__dirname, 'dist'), //监听的文件夹 host: 'localhost', //服务器地址，本机ip地址，不建议使用locahost ，防止映射表被修改，出现解析不到的情况。ifconfig 查看 本机ip compress: true,//服务器端压缩 port:1717 //服务器端口，默认80 &#125;, 注意：在翻墙的情况下 host: 填写本机ip 会报错，使用 localhost 打包css文件首先需要安装两个包 style-loader css-loader 来实现对css 文件的转换。 1npm i style-loader css-loader --save-dev style-loader:处理css中的 url css-loader:处理css中的样式 在src文件夹中建立css文件,并且在 入口文件 或者 入口依赖的其他js文件 中引入：1import css from './css/index.css'; webpack.config.js中的配置： 12345678module: &#123; rules: [ &#123; test: /\.css$/, //用正则表达式的形式来找到处理的文件 use: ['style-loader', 'css-loader']//使用哪些loader来处理 &#125; ] &#125;, 另一种常用写法可以使每个loader 可以配置选项：123456789101112module: &#123; rules: [ &#123; test: /\.css$/, use: [&#123; loader:"style-loader" &#125;, &#123; loader:"css-loader" &#125;] &#125; ] &#125;, 压缩js文件对js文件做代码压缩，需要使用到 webpack 内置的 uglifyjs-webpack-plugin 这个插件。 123456//webpack.config.jsconst UglifyJSPlugin = require('uglifyjs-webpack-plugin');plugins: [ new UglifyJSPlugin() ], 然后 npm start 发现打包出来的代码被压缩了。 这里遇到了一个坑。。。 接上一步开启服务器 npm run server ，命令行报错 ERROR in entry.js from UglifyJsUnexpected token: name (urlParts) [entry.js:325,4] 原因在于：没有区分 开发环境 和 生产环境 。开发环境中代码是不需要压缩的。如果压缩了，调试没有办法找到对应的行号。代码压缩只需要再 生产环境 中进行，在开发环境中压缩代码，跑服务器造成了冲突，具体情况不清楚。正常的项目开发是不会产生这样的问题的，都会有一个 开发使用的配置文件 和 生产使用的配置文件 。 HTML文件的打包一般项目开发是严格区分 开发环境 和 生产环境 的，也就是 src 文件是我们的 开发环境 的项目代码文件夹，dist 文件夹是打包后自己生成的，不需要我们自己去创建。把 index.html 文件放在 src 目录下面，删除文件里面的 script 标签，html-webpack-plugin 会自动帮我们加入引入js的script标签。 1npm i -D html-webpack-plugin 项目中的配置 123456789101112//webpack.config.jsconst htmlPlugin = require('html-webpack-plugin')plugins: [ new htmlPlugin(&#123; minify: &#123; removeAttributeQuotes: true,//去掉标签中的引号 &#125;, hash: true, //引用js时有缓存，加上hash后每次都会给个不同的字符串。 template:'./src/index.html' &#125;) ], 打包后发现自动的新建了 dist 文件夹和里面的打包文件。 这里注意配置的写法，大括号太多。我写错了导致打包后的文件异常，找了半天问题 (⊙﹏⊙)b。 项目中引入图片css中引入图片eg:123456/* src/css/index.css */#img&#123; background-image:url(../img/img.png); width:120px; height:101px;&#125; 首先需要安装 url-loader 这个插件配置 webpack.config.js 文件： 12345678910111213&#123; rules:[ &#123; test: /\.(png|jpg|gif)$/, use: [&#123; loader: 'url-loader', options: &#123; limit:5000, &#125; &#125;] &#125; ]&#125; 注意：loader是不需要引入的。 limit:5000 的意思是：图片大于5000字节,自动拷贝图片到 dist 文件，并且在 bundle.js 文件中（打包后的js文件）修改正确的路径（包含了 file-loader 的一些功能）。如果小于5000,会生成base64位格式的图片直接插入到js文件中,好处是减少了http请求。 HTML中引入图片webpack 官方是不建议我们在html中引入图片的，如果有这种需求，直接添加 image 标签引入图片，打包后发现，图片并没有被打包到 dist 文件夹下面，因为图片没有被依赖。eg: 12&lt;-- index.html --&gt;&lt;div&gt;&lt;image src="./img/img.png"/&gt; &lt;/div&gt; 解决这个问题需要装 html-withimg-loader插件，然后配置： 1234567//webpack.config.jsloaders: [ &#123; test: /\.(htm|html)$/i, loader: 'html-withimg-loader' &#125;] CSS样式分离和publickPath设置CSS样式分离一般项目中css文件都是直接打包进 bundle.js 文件中去的，这样可以减少 http 请求。但是在某些时候，我们不想把 css 文件打包进入 bundle.js 文件中，比如：一个项目全是靠css样式来布局，js代码非常少得情况下，项目总监要求把项目交给切图仔维护等需求。如何实现呢： 1npm i -D extract-text-webpack-plugin 123456//webpack.config.jsconst extractTextPlugin = require('extract-text-webpack-plugin')plugins:[ new extractTextPlugin("css/index.css") //把css文件放在服务器的根目录（这里是dist文件夹下），下的css文件夹中。] css loader 也需要做一些更改 1234567&#123; test: /\.css$/, use: extractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: &quot;css-loader&quot; &#125;)&#125; publickPath设置打包代码，跑本地服务器，这时候发现图片没有了，查看打包后的项目结构，发现css文件中的路径有问题。 这时候需要设置 publiPath 公用路径，解决静态文件的路径问题。 12345678//webpack.config.jsvar website = &#123; publicPath:'http://192.168.1.105:1717/' //注意这里的斜杠，ip为服务器ip（在这里是你的计算机ip）&#125;output: &#123; ... publicPath:website.publicPath&#125; 重新打包，css文件中图片的路径变为了正确的绝对路径。 打包和分离LESS打包LESS文件到 bundle.js 文件中首先需要安装 less 、 less-loader 这两个包1npm i -D less less-loader webpack.config.js 配置 12345678910111213141516// webpack.config.jsmodule.exports = &#123; ... module: &#123; rules: [&#123; test: /\.less$/, use: [&#123; loader: "style-loader" // creates style nodes from JS strings &#125;, &#123; loader: "css-loader" // translates CSS into CommonJS &#125;, &#123; loader: "less-loader" // compiles Less to CSS &#125;] &#125;] &#125;&#125;; 注意loaderde顺序，顺序错误会造成打包失败的情况。 然后编写LESS文件，引入到入口JS文件中，就可以了。 分离LESS文件和分离css文件类似，需要用到 extract-text-webpack-plugin 这个包，上面已经安装了，这里不需要安装了。 12345678910111213141516//webpack.config.js const extractTextPlugin = require('extract-text-webpack-plugin')&#123; test: /\.less$/, use: extractTextPlugin.extract(&#123; use: [ &#123; loader: 'css-loader' &#125;, &#123; loader: 'less-loader' &#125; ], fallback:'style-loader' &#125;)&#125;plugins: [ new extractTextPlugin("css/index.css")] 打包后会把LESS中的样式转换成CSS样式，并且打包进index.css 文件中去，这里并不会新建一个CSS文件。 SASS的打包和分离SASS的打包将SASS转换成CSS，并且打包进bundle.js文件中去： 1npm i -D node-sass sass-loader 123456789//webpack.config.js&#123; test: /\.scss$/, //注意这里的 SCSS，不是SASS use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader' &#125;, &#123; loader: 'sass-loader' &#125; ]&#125; 在项目中引入打包就可以了。 SASS的分离和LESS分离步骤几乎一样 12345678910111213141516//webpack.config.js const extractTextPlugin = require('extract-text-webpack-plugin')&#123; test: /\.scss$/, use: extractTextPlugin.extract(&#123; use: [ &#123; loader: 'css-loader' &#125;, &#123; loader: 'sass-loader' &#125; ], fallback:'style-loader' &#125;)&#125;plugins: [ new extractTextPlugin("css/index.css")] 自动添加CSS属性前缀1npm i -D postcss-loader autoprefixer 需要再项目的根目录新建 postcss.config.js 配置文件。 123456//postcss.config.jsmodule.exports = &#123; plugins: [ require('autoprefixer') ]&#125; 1234567891011//webpack.config.js&#123;test: /\.css$/,use: extractTextPlugin.extract(&#123; fallback: "style-loader", use: [ &#123; loader: 'css-loader' &#125;, &#123; loader: 'postcss-loader' &#125; //here ]&#125;)&#125; 更多的配置参考 postcss-loader 分离多余的CSS样式有些时候css样式有多余的情况，比如使用 Bootstrap 这个库文件一小部分样式，或者项目几次改版产生了很多无效的CSS样式，这种情况下需要去除掉多余的CSS样式，以节省带宽。安装webpack插件 :1npm i -D purifycss-webpack purify-css 配置选项： 12345678910//webpack.config.jsconst glob = require('glob');const purifyCssPlugin = require('purifycss-webpack')const extractTextPlugin = require('extract-text-webpack-plugin')plugin:[ ..., new purifyCssPlugin(&#123; paths:glob.sync(path.join(__dirname,'src/*.html')) &#125;)] 这样就实现了多余代码的去除，好像是需要结合 CSS分离（extract-text-webpack-plugin）技术，才能实现代码的去除。自己测试过程：把CSS分离去除后，也就是让CSS代码打包进 bundle.js 文件里面，配置好代码，打包后没有去除掉多余的CSS文件，在 bundle.js 文件里面还能找到样式。 使用Babel转换ES6和ES7语法首先需要安装插件，我是结合 React 项目来使用 ES6 ES7 的，所以需要安装 babel-preset-react 来解析 React 的 jsx 语法。1npm i -D babel-core babel-loader babel-preset-env babel-preset-react 12345678910111213//webpack.config.js&#123; test: /\.(js|jsx)$/, use: [ &#123; loader: 'babel-loader' , //options:&#123; 这里注意实际中不会这样配置，一般新建.babelrc文件来写这些配置项 // presets:["env","react"] //&#125; &#125; ], exclude: /node_modules/ //不需要转换node_modules下的js文件&#125; 实际开发中 babel 的配置代码会越来越多，不建议在 use 中写 babel 的配置选项，而是在项目的根目录新建 .babelrc 配置文件。 1234//.babelrc&#123; "presets": ["react","env"] //渲染器&#125; 打包后的代码调试打包有四种模式： source-map : 打包速度最慢，最详细，生成了一个 .map的独立的文件,放在 dist 打包目录下，可以与打包后的文件很好的结合，报错信息包括 行 和 列。 cheap-module-source-map : 也生成独立文件，报错信息包括 行 和 不包括列，比上面的模式快。 eval-source-map : 不生成独立文件,报错信息包括 行 和 列，直接在 bundle.js 文件中生成 map, 速度也很快，有安全和性能的隐患，只能在开发阶段使用，上线前一定要删除 devtool:&#39;eval-source-map&#39;。 cheap-module-eval-source-map :不生成独立文件, 报错信息包括 行 和 不包括列列， 123456789//webpack.config.jsmodule.exports = &#123; devtool:'source-map', //here entry: &#123;&#125;, output: &#123;&#125;, module: &#123;&#125;, plugins: [], devServer: &#123;&#125;&#125; 参考教程]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native笔记本]]></title>
    <url>%2F2018%2F09%2F25%2Freact-native%E7%AC%94%E8%AE%B0%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[android App跳转到设置页面如何原生模块实现? Stack Overflow android 设置 常量列表 android App，设置禁止横屏。 AndroidManifest.xml 文件中的 &lt;activity&gt; 标签内添加 android:screenOrientation=&quot;portrait&quot; ios android 设置App 名称 ios : 在 Info.plist中修改 Android : android\app\src\main\res\values\strings.xml 文件中修改 &lt;string name=&quot;app_name&quot;&gt;MyProject&lt;/string&gt; ios android 设置icon图标 ios: 首先在这里 上传你的图标，注意：四个圆角边要透明的，如果是白色的在安卓上可能显示出来。 然后直接 project/ios/project_name/images.xcassets/ 直接替换。 android: 直接替换掉 project/android/app/src/main/res 里面的文件夹。 ios android 设置启动图 ios: 使用图片工具 App Icon Gear 来生成不同尺寸的图片 之后 参考 注意： android: 使用 react-native-splash-screen 来实现。 可以使用 这里 来生成android 的图片，注意生成后,每个文件夹里面的每张图名称需要更改为 launch_screen 然后配置 react-native-splash-screen ，就可以使用的了。 碰到的坑：按照文档配好后，出现ios 正常 ，android启动闪退, “Unfortunately, app has stopped”, 解决办法 解决TextInput 框点击空白处不失去焦点问题 在 TextInput 最外层的根节点加一个 ScrollView ,添加 keyboardShouldPersistTaps={‘never’}。 或者在最外层添加 TouchableOpacity 1234567891011121314151617import dismissKeyboard from 'dismissKeyboard'dismissKeyboardClick = () =&gt; &#123; dismissKeyboard() &#125;render()&#123; return （ ... &lt;TouchableOpacity style=&#123;&#123; flex: 1 &#125;&#125; onPress=&#123;this.dismissKeyboardClick&#125; activeOpacity=&#123;1&#125; &gt; //TextInput组件 &lt;TouchableOpacity/&gt; ...） &#125; react-native webview 如何引入本地html文件 ios : 直接 source={require(&#39;../../assets/html/message.html&#39;)} android : Android 需要先把静态资源放到 android/app/src/main/assets 目录下面，然后把 require(&#39;../../assets/html/message.html&#39;) 换成 {uri: &#39;file:///android_asset/html/message.html&#39;}。 解决 android 绝对定位元素定位在底部被键盘顶起问题 如果希望被顶起：android:windowSoftInputMode=&quot;adjustResize&quot; TextInput 组件设置 value 值不显示的问题value 值类型为字符串，设置成Number 类型不显示]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js代码片段难点集合]]></title>
    <url>%2F2018%2F09%2F25%2Fjs%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E9%9A%BE%E7%82%B9%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[如何理解12345function test(a,b,c) &#123; var _args = [].slice.call(arguments); console.log(_args)&#125;test(1,2,3) 如何封装一个柯里化通用式思路柯里化运行的过程是一个参数收集过程，并在最里面处理 12345678910111213141516171819// 简单实现，参数只能从右到左传递function createCurry(func, args) &#123; var arity = func.length; var args = args || []; return function() &#123; var _args = [].slice.call(arguments); [].push.apply(_args, args); // 如果参数个数小于最初的func.length，则递归调用，继续收集参数 if (_args.length &lt; arity) &#123; return createCurry.call(this, func, _args); &#125; // 参数收集完毕，则执行func return func.apply(this, _args); &#125;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax跨域解决思路]]></title>
    <url>%2F2018%2F09%2F25%2Fajax%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[为什么会发生AJAX跨域？浏览器限制当浏览器发现请求是跨域的时候，它会做一些校验，如果校验不通过它就会报跨域安全错误。 跨域发出去的请求，协议、端口、请求地址，任何一个不一样，浏览器就会认为是跨域。 发送的是 XHR(XMLHttpRequest) 请求如果发送的不是XHR请求，就算是跨域，浏览器也不会报错。 解决问题的思路1.浏览器限制，我们就解除浏览器的跨域限制，从命令行中启动chrome。 open -n /Applications/Google\ Chrome.app/ --args --disable-web-security --user-data-dir=/Users/wenxiangye/MyChromeDevUserData/ 2.JSONP如何解决跨域问题？利用JQ实现JSONP请求 123456789$.ajax(&#123; url: base+"/get1", dataType: "jsonp", jsonp: "callback2", //默认不写前后端约定的名称是 callback cache: true, //表示结果可以被缓存，jsonp请求url中不会带 `_`字段 success: function(json)&#123; result = json; &#125;&#125;) 有三个不同点: 请求的Type不同 请求返回的 Content-Type 不同 JSON请求的URL后面自动加了callback 动态创建&lt;script&gt;标签，请求的资源可以跨域，来解决跨域问题的（eg：&lt;img&gt;标签中请求图片的地址可以跨域）后台代码也需要做处理，因为后台代码返回的是JSON，而通过JSONP请求的是JS文件，浏览器会把后台返回的JSON字符串当成是JS来解析，所以报错了。后台代码需要做的调整就是：请求参数中发现callback 这个字段，需要返回JS代码，callback 后面的值作为函数名，而请求需要返回的参数，作为函数的参数。 动态创建的script请求完毕后会被销毁，所以dom结构中无法查看，需要再JQ源码中9816行出打断点查看。 jsonp请求里面除了callback参数之外还多了一个_参数，参数值是一个随机的数字，防止请求被缓存。 JSON弊端： 服务器需要做一些改动。 只支持GET 发送的不是XHR请求，（XHR有很多新的特性，比如异步。） 3.被调用方解决跨域问题响应头增加字段，告诉浏览器允许跨域。浏览器发现请求是跨域的时候，他会在请求头增加当前域的字段Origin: http://localhost:8081 等请求返回来，他会检查响应头里面的字段信息，是否允许跨域。后端需要在响应头增加 ：Access-Control-Allow-Origin:http://localhost:8081Access-Control-Allow-Methods:GET两个字段都可以填写*表示所有域名和请求都可以跨域 简单请求和非简单请求浏览器在发送跨域请求的时候，会先判断跨域是简单请求还是非简单请求，如果是简单请求它会先执行，后判断。如果是非简单请求，会发一个OPTIONS的预检命令，检查通过后，他会把真正的请求发送过去。 简单请求的定义：方法为GET POST HEAD 、无自定义头部、Content-Type为：text/plain、multipart/form-data、application/x-www-form-urlencoded 三种。 非简单请求：方法为 PUT, DELETE 方法的ajax请求、发送json格式的ajax请求、带自定义头的请求 非简单请求时，如果跨域了，浏览器首先发送一个OPTIONS预检请求，在预检请求中会有一个字段 Access-Control-Request-Method: content-type ，询问后台服务器是否允许 content-type 这个头，如果响应头部没有通过的信息，就会报跨域的错误。 解决方法： 后台代码需要增加头信息 Access-Control-Allow-Headers: Content-Type 非简单请求每个跨域请求都会请求两次，这样非常影响效率，响应可以增加一个头信息，来缓存预检命令，Access-Control-Max-Age: 3600 这个头信息的意思是告诉浏览器，在3600秒内，可以缓存预检命令的结果，不需要发送预检命令。 带cookie的跨域：当响应头Access-Control-Allow-Origin: * 时，是不能满足带cookie的跨域请求的，前端设置 ： 1234567$.aiax(&#123; ..., xhrFields:&#123; withCredentials:true &#125; ...&#125;) 后端设置头信息 Axxess-Control-Allow-Origin: http://localhost:8081和Access-Control-Allow-Credentials: true 但是这样做之后，浏览器只会允许 http://localhost:8081 这个地址来跨域，如果需要多个地址请求实现跨域如何实现呢？之前知识点： 浏览器发现请求是跨域的时候，他会在请求头增加当前域的字段Origin: http://localhost:8081 等请求返回来，他会检查响应头里面的字段信息，是否允许跨域。后端可以动态的去取 Origin这个字段的值，如果不为空，则 Axxess-Control-Allow-Origin: Origin,现在就可以支持任何的跨域调用了。 带自定头的跨域首先前端定义： 可以发现请求头部增加了如下内容： 此时去请求发现报错报错信息的意思是：在返回头Access-Control-Allow-Headers 字段中没有 x-header2 的信息，把 x-header1 x-header2 加进去就行了，最好是动态的获取请求头Origin里面的值去添加，这样就支持所有的自定义头部了。 虚拟主机上设置响应头信息之前我们是直接在应用服务器上面修改响应头信息，现在我们建立一个虚拟主机，在虚拟主机上面修改响应头信息被调用方的虚拟主机的配置。 第一步首先配置HOST文件eg: 1127.0.0.1 b.com 打开nginx中的config目录 新建一个 vhost目录，在里面新建虚拟主机的配置文件。打开 nginx.config 文件,在最后增加 1include vhost/*.conf //让nginx载入这个目录下的所有.conf文件 在vhost目录中新建一个 b.com.config文件，里面写入下面代码 12345678910111213141516server&#123; listen 80; //监听的端口 server_name b.com; //监听的域名 location /&#123; proxy_pass http://localhost:8080/; //把所有的请求都转到 8080,监听80端口，域名为b.com add_header Access-Control-Allow-Methods *; add_header Access-Control-Max-Age 3600; add_header Access-Control-Allow-Credentials true; add_header Access-Control-Allow-Origin $http_origin; //获取请求头里面的值 add_header Access-Control-Allow-Headers $http_access_control_request_headers; if ($request_method = OPTIONS)&#123; return 200; //把跨域的预检命令直接在虚拟主机上处理，不经过应用主机。 &#125; &#125;&#125; 启动nginx start nginx 调用方解决跨域通过反向代理来实现,隐藏跨域。 正向代理：它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求。 反向代理:它隐藏了真实的服务端，当我们请求 www.baidu.com 的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，www.baidu.com 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。 两者的区别在于代理的对象不一样：正向代理代理的对象是客户端，反向代理代理的对象是服务端。摘自知乎-刘志军的回答 1127.0.0.1 b.com a.com //增加一个a.com，用它表示调用方的虚拟主机 在vhost目录中新建一个 a.com.config文件，里面写入下面代码 123456789101112server &#123; listen 80: server_name a.com; location /&#123; proxy_pass http://localhost:8081/; &#125; location /ajaxserver&#123; //把我们要调用的服务器代理成 ajaxserver proxy_pass http://localhost:8080/test/; &#125;&#125; 请求的代码中修改请求的基本前缀 1var base = '/ajaxserver';]]></content>
      <tags>
        <tag>ajax</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-redux_使用装饰器优化connect代码]]></title>
    <url>%2F2018%2F09%2F24%2Freact-redux-%E4%BD%BF%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8%E4%BC%98%E5%8C%96connect%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[项目是使用 create-react-app 创建 npm run eject弹出个性化配置 npm i babel-plugin-transform-decorators-legacy 插件 package.json里babel加上plugins配置]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMD-CMD-CommonJs和ES6对比]]></title>
    <url>%2F2018%2F09%2F24%2FAMD-CMD-CommonJs%E5%92%8CES6%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[AMDAMD 是 RequireJS在推广过程中对模块定义的规范化产出,推崇依赖前置。 12345678define(['package/lib'],fucntion(lib)&#123; function()&#123; lib.log('hello world!') &#125; return &#123; foo: foo &#125;&#125;) 优点：代码一旦运行到此处，能立即知晓依赖。而无需遍历整个函数体找到它的依赖，因此性能有所提升。加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。缺点：就是开发者必须显式得指明依赖——这会使得开发工作量变大，比如：当你写到函数体内部几百上千行的时候，忽然发现需要增加一个依赖，你不得不回到函数顶端来将这个依赖添加进数组。 CMDCMD是SeaJS在推广过程中对模块定义规范化产出，推崇依赖就近。 123456//所有模块通过 define定义define(function(require, exports. module)&#123; //通过 require 引入依赖 var $ = require(&apos;jquery&apos;) var Spinning = require(&apos;./spinning&apos;)&#125;) CommonJS是node服务端的一个规范,只在服务端使用，浏览器并不支持。 123export.area = function(r)&#123; return Math.PI * r * r;&#125; ES6 export/import]]></content>
      <tags>
        <tag>模块化规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa笔记]]></title>
    <url>%2F2018%2F09%2F24%2Fkoa%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Context对象Koa提供一个Context对象，表示一次对话的上下文（包括HTTP请求和HTTP回复），通过给这个对象赋值可以控制返回给用户的内容。 eg: 12345678const Koa = require('koa);const app = new Koa();const main = ctx =&gt; &#123; ctx.response.body = 'Hello World';&#125;;app.use(main);app.listen(3000); 给响应的body 添加内容Koa默认返回的类型是 text/plain。可以使用 ctx.request.accepts(&#39;json&#39;) 来判断客户端接收什么数据，同时设置返回的类型 ctx.response.type = &#39;json&#39;。 1234ctx.response.body = 'Hello World'; //textctx.response.body = &#123; data: 'Hello World' &#125;; //jsonctx.response.body = '&lt;p&gt;Hello World&lt;/p&gt;'; //htmlctx.response.body = '&lt;data&gt;Hello World&lt;/data&gt;'; //xml 网页模板Koa先读取模板文件，然后返回给用户 1ctx.response.body = fs.createReadStream('./demos/template.html'); 路由原生路由是通过 ctx.request.path 可以获取用户请求的路径,由此判断该返回什么内容给用户，使用不方便，一般使用 koa-route. 12345const about = ctx =&gt; &#123; ctx.response.type = 'html'; ctx.response.body = '&lt;a href="/"&gt;Index Page&lt;/a&gt;';&#125;;app.use(route.get('/about', about)); 静态资源如果服务器需要返回给用户一些静态资源（图片，字体，样式表，脚本），一个个写路由很麻烦，可以使用 koa-static 。 1234567const Koa = require(&apos;koa&apos;);const app = new Koa();const path = require(&apos;path&apos;);const server = require(&apos;koa-static&apos;)const publicServer = server(path.join(__dirname) + &apos;/public&apos;);app.use(publicServer);app.listen(3000); 这样用户可以访问 __dirname 文件夹下的所有文件。eg:输入http://localhost:3000/01.js ，可以查看 __dirname 文件夹下的 01.js 文件。 路由重定向ctx.response.redirect(&#39;/&#39;) 方法可以发出一个302跳转,将用户导向另一个路由。 中间件Koa最重要的一个设计就是中间件，比如打印日志中间件简单的写法，可以直接main函数中写 console.log(...)， 也可以拆分成一个独立函数（如下） 12345678910const logger = (ctx, next) =&gt; &#123; console.log(`$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); next();&#125;const main = ctx =&gt; &#123; ctx.response.body = 'Hello World';&#125;;app.use(logger);app.use(main);app.listen(3000); 上面的代码 logger 函数就叫 中间件。 中间件：处于 HTTP Request 和 HTTP Response 中间，用来实现某种中间功能， app.use() 用来加载中间件。 中间件默认有两个参数，(Context, next), 只要调用 next() 就把执行权交给下一个中间件。 123456789101112131415161718const one = (ctx, next) =&gt; &#123; console.log('&gt;&gt; one'); next(); console.log('&lt;&lt; one');&#125;const two = (ctx, next) =&gt; &#123; console.log('&gt;&gt; two'); next(); console.log('&lt;&lt; two');&#125;const three = (ctx, next) =&gt; &#123; console.log('&gt;&gt; three'); next(); console.log('&lt;&lt; three');&#125;app.use(one);app.use(two);app.use(three); 三个中间件: one中间件 、 two中间件 、 three中间件。执行步骤 ：最外层 one 首先执行,调用next()方法后,next()方法后面的代码并不会执行,而是把执行权交给下一个中间件 two,同理交给 three 。我的理解是：next() 后面的代码被放入了任务队列，当主线程也就是 next() 之上的代码执行完毕后，执行任务队列的代码，任务队列里面的代码以 先进后出 的顺序执行。 如果删除 two 中间件函数中的 next() ,执行权并不会交给 three 中间件，也就是说 three并不会被执行。 异步中间件12345const fs = require('fs.promised');const main = async function (ctx, next) &#123; ctx.response.type = 'html'; ctx.response.body = await fs.readFile('./demos/template.html', 'utf8');&#125;; 中间件合成 koa-compose1234567891011const compose = require('koa-compose')const logger = (ctx, next) =&gt; &#123; console.log(ctx); next()&#125;const main = ctx =&gt; &#123; ctx.response.body = 'Hello World'&#125;const middlewares = compose([logger, main])app.use(middlewares) 错误处理如果代码运行过程中发生错误，我们需要把错误信息返回给用户，可以使用 ctx.throw(statusCode) 来返回, ctx.response.status = 404 等价于 ctx.throw(404) 。 为了方便处理错误，最好使用 try...catch, 每个中间件写太麻烦，可以让最外层的中间件负责所有处理 123456789101112131415const handler = async (ctx, next) =&gt; &#123; try &#123; await next(); &#125; catch (err) &#123; ctx.response.status = err.statusCode || err.status || 500; ctx.response.body = &#123; message: err.message &#125;; &#125;&#125;;const main = ctx =&gt; &#123; ctx.throw(500);&#125;;app.use(handler);app.use(main); 以上代码，由于 main中间件中抛出了错误，会执行 最外层中间件handler catch里面的代码。 错误事件监听代码运行过程中出错，Koa会触发一个 error 事件。 1234//错误事件监听app.on('error', (err, ctx) =&gt; console.error('server error', err);); 如果错误被 try...catch 捕获， 就不会触发error事件，必须调用 ctx.app.emit() 手动释放 error 事件，才能让监听函数生效。 12345678const handler = async (ctx, next) =&gt; &#123; try &#123; await next(); &#125; catch (err) &#123; //... ctx.app.emit('error', err, ctx); &#125;&#125; 读写 cookies1234const main = ctx =&gt; &#123; ctx.cookies.get('view'); ctx.cookies.set('view', n);&#125; koa-body 提取键值对他可以用来提取POST请求体中的键值对,类似于 name=Jack 1234567891011const koaBody = require(&apos;koa-body&apos;);const app = new Koa();const main = async function(ctx) &#123; const body = ctx.request.body; console.log(body) if (!body.name) ctx.throw(400, &apos;.name required&apos;); ctx.body = &#123; name: body.name &#125;;&#125;;app.use(koaBody());app.use(main); 获取GET请求中的查询参数 ctx.request.query ctx.query koa-view使用1234567891011const views = require(&apos;koa-views&apos;)const &#123; resolve &#125; = require(&apos;path&apos;)app.use(views(resolve(__dirname, &apos;./views&apos;),&#123; extension:pug&#125;)app.use(async (ctx, next) =&gt; &#123; await ctx.render(&apos;index&apos;,&#123; title:&apos;ye&apos; &#125;)&#125;)]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[媒介查询]]></title>
    <url>%2F2018%2F09%2F24%2F%E5%AA%92%E4%BB%8B%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[使用CSS3的 Media Query 查询1.外链方式 1&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;link.css&quot; media=&quot;only screen and (max-width:480px)&quot;/&gt; 只有当屏幕宽度 &lt;= 480px 时，才会加载这个CSS文件。 2.内嵌方式 12345@media screen and (min-width: 480px)&#123; body&#123; background:blue; &#125;&#125; 当屏幕宽度 &gt;= 480 时 body 背景为蓝色。]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx笔记]]></title>
    <url>%2F2018%2F09%2F24%2Fnginx%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[客户端nginx路径信息配置文件路径: /usr/local/etc/nginx/nginx.conf服务器默认路径: /usr/local/var/www安装路径: /usr/local/Cellar/nginx/1.13.9 启动直接终端输入 nginx 启动，可以使用 ps -ef|grep nginx 来查看是否启动成功进程号为 3843在终端输入 kill -term 3843 来停止进程 重启12nginx -s reloadservice nginx reload #不停服务重启 查找配置文件路径mac下使用homebrew 安装 nginx 的路径：/usr/local/etc/nginx/nginx.conf1ps -ef | grep nginx 403 Forbidden权限问题解决12sudo chown -R $USER:$USER /root/www/blogsudo chmod -R 755 /root/www]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端常用CSS代码]]></title>
    <url>%2F2018%2F09%2F24%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E7%94%A8CSS%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1px边框问题使用123456789101112131415161718.xx&#123; position:relative;&#125;.xx:before&#123; content:''; position: absolute; top: 0; left: 0; border: 1px solid #ccc; width: 200%; height: 200%; box-sizing:border-box; -webkit-box-sizing:border-box; -webkit-transform: scale(0.5); transform: scale(0.5); -webkit-transform-origin: left top; transform-origin: left top;&#125; 背景图裁切123456.xx&#123; background-image:url('...'); background-position:center center; background-size:cover; background-repeat:no-repeat;&#125; 横向滚动1234567.parent&#123; display: -webkit-box; overflow-x: scroll; overflow-y: hidden; -webkit-overflow-scrolling: touch; /* 弹性滑动 */&#125; 单行显示，超过省略号12345.xx&#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125; 两行显示，超过省略号1234567.xx&#123; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>移动端常用CSS代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node异步编程方案]]></title>
    <url>%2F2018%2F09%2F24%2Fnode%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[回调函数 (第一阶段)123456789101112function readFile (cb)&#123; fs.readFile(path, (err, data) =&gt; &#123; if (err) console.log(err) else console.log(data) &#125;)&#125;readFile((err, data) =&gt; &#123; if(!err)&#123; data = JSON.parse(data) console.log(data.value) &#125;&#125;) promise (第二阶段)12345678910111213141516function readFileAsync(path) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(path, (err, data) =&gt; &#123; if (err) reject(err) else resolve(data) &#125;) &#125;)&#125;readFileAsync('./package.json') .then(data =&gt; &#123; data =JSON.parse(data) console.log(data) &#125;) .catch(err=&gt;&#123; console.log(err) &#125;) 通过utli.promisify() 方法包装只能传递一个异步回调函数，返回一个promise Function,第二个括号为传递的参数 123456789101112const utli = require('util')utli.promisify(fs.readFile)('./package.json') .then(data =&gt; &#123; return JSON.parse(data) &#125;) .then(data =&gt; &#123; console.log(data.name) &#125;) .catch(err=&gt;&#123; console.log(err) &#125;) 结合使用 async await1234567891011const readAsync = utli.promisify(fs.readFile)async function init ()&#123; try&#123; let data = await readAsync('./package.json') data = JSON.parse(data) console.log(data.name) &#125; catch(err)&#123; console.log(err) &#125;&#125;init() Generator其本质是一个迭代器，下面来实现一个类似的迭代器 12345678910111213141516function makeIterator (arr)&#123; let nextIndex = 0 //返回一个迭代器对象 return &#123; next: () =&gt; &#123; if(nextIndex &lt; arr.length)&#123; return &#123;value: arr[nextIndex++], done: false&#125; &#125; else &#123; return &#123;done: true&#125; &#125; &#125; &#125;&#125;const it = makeIterator(['吃饭', '睡觉'])console.log(it.next().value) //吃饭console.log(it.next().value) //睡觉 生成器（Generator）：返回迭代器的函数,简化自己创建迭代器繁琐的过程，同时保持逻辑的清晰性。 12345678funciton *makeIterator (arr)&#123; for(let i = 0; i &lt; arr.length; i++)&#123; yield arr[i] &#125;&#125;const gen = makeIterator(['吃饭', '睡觉'])console.log(gen.next().value) //吃饭console.log(gen.next().value) //睡觉 co 与 Generator (第三阶段)12345678const co = require('co')const fetch = require('node-fetch')co(function *()&#123; const res = yield fetch('https://api.douban.com/v2/movie/1291843') const movie = yield res.json() const summary = movie.summary console.log(summary)&#125;) 通过co 这个库，可以传递一个Generator函数,就可以通过同步的方式，来执行异步的过程。通过 yield 关键字可以实现一个状态的暂停，当 yield后面的异步代码没有执行完毕时，后面的代码不会执行。简单来说co 函数能让里面 yield 暂停的函数都能得到一步步的执行，实现了 Generator 的自动执行 async Function （第四阶段 统一世界）123456const = readAsync = utli.promisify(fs.readFile)async function init ()&#123; let data = await readAsync('./package.json') data = JSON.parse(data) console.log(data.name)&#125;]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoDB操作]]></title>
    <url>%2F2018%2F09%2F24%2FmongoDB%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[创建12&gt; post = &#123;"title": "my blog post", "content":"here's my blog post", "date": new Date()&#125;&gt; db.blog.insert(post) javascript shell 中， db 命令现当前所在的数据库，上面代码，在当前数据库中的 blog集合 插入 post文档。可以使用 db.blog.find() 查找 blog 集合中保存的所有文档。 读取find(): 会返回集合里面所有的文档，若只想查看一个文档可以使用 findOne 1&gt; db.blog.findOne() 更新update: 接收至少两个参数: 第一个是更新文档的限定条件 第二个是新文档 第三个参数为true时，表示开启 upsert 更新模式，要是没有文档符合更新条件，就会以这个条件和更新文档为基础创建一个新文档，如果找到则正常更新。 第四个参数为true时，表示开启多文档更新，默认为false，只能匹配并更新一个。 比如给上面的文档增加一个 comments 字段，值为[] 12&gt; post.comments = []&gt; db.blog.update(&#123;title:&quot;my blog post&quot;&#125;, post) 例子：删除数据库集合中某个字段 1db.User.update(&#123;&#125;,&#123;$unset:&#123;&apos;address&apos;:&apos;&apos;&#125;&#125;,false, true) 使用修改器利用原子的 更新修改器，使得这部分修改极为高效。比如页面访问统计 12345&#123; "_id" : ObjectId("5b430d4da1d1ea0fd260cae5"), "url" : "www.baidu.com", "pageviews" : 52&#125; 12&gt; db.blog.update(&#123;"url":"www.baidu.com"&#125;, &#123;"$inc":&#123;"pageviews":1&#125;&#125;)# 会将上面的pageviews + 1， 如果update 第一个参数匹配到多个文档，只会更新第一个,所以一般选择ID作为条件 “$set”修饰器用来指定一个键的值，如果这个键不存在则创建。（更新键的值，或者数据类型。） 1&gt; db.blog.update(&#123;"_id":ObjectId("5b431136a1d1ea0fd260cc3e")&#125;, &#123;"$set":&#123;"favorite book": "war and peace"&#125;&#125;) 可以修改类型: 1&gt; db.blog.update(&#123;"_id":ObjectId("5b431136a1d1ea0fd260cc3e")&#125;, &#123;"$set":&#123;"favorite book": ["cat", "dog"]&#125;&#125;) 修改嵌套文档 “$unset”修饰器将一个键完全删除 1&gt; db.blog.update(&#123;"_id":ObjectId("5b431136a1d1ea0fd260cc3e")&#125;, &#123;"unset": &#123;"favorite book": 1&#125;&#125;) “$inc”修饰器用来增加已有键的值，或者在键不存在时创建一个键。 12&gt; db.blog.update(&#123;"game":"pinball","user":"joe"&#125;,&#123;"$inc":&#123;"score":50&#125;&#125;)# 每次增加50,可以为负值 “$inc” 专门用来增加和减少数字的，只能用于整数、长整数或双精度浮点数 数组修改器“$push” 会向已有的数组末尾加入一个元素，要是没有就创建一个新的数组。 情景：值不在数组中时，把它加进去，可以在查询文档中使用 “$ne” 来实现。 1&gt; db.blog.update(&#123;"authords cited": &#123;"$ne": "Richie"&#125;, &#123;"$push": &#123;"authords cited": "Richie"&#125;&#125;&#125;) 也可以使用 “$addToSet” 完成同样的事情,向数组添加值，避免重复。 “$addToSet” 可以和 “$each” 结合使用，一次添加多个不同的值 1234567&gt; db.blog.update(&#123;"_id": ObjectId("5b431136a1d1ea0fd260cc3e")&#125;, &#123; "$addToSet":&#123; "emails" :&#123; "$each" : ["dsa@qq.com", "dsd3aa@qq.com", "dsd2a@qq.com"] &#125; &#125;&#125;) “$pop”修饰器1&#123;$pop: &#123;key:1&#125;&#125; //从数组末尾删除一个元素, key:-1 从头部删除 “$pull”修饰器“$pull” 可以特定条件来删除元素，不仅仅是依据位置。 123&gt; db.lists.insert(&#123;"todo": ["dishes", "laundry", "dry cleaning"]&#125;)&gt; db.lists.update(&#123;&#125;, &#123;"$pull": &#123;"todo":"laundry"&#125;&#125;)# 会删除数组中的laundry ,如果有多个，会全部删除。 数组的定位修改器假设文档中 comments 字段是一个数组，里面包含多个对象 12345&gt; db.blog.update(..., &#123;"$inc": &#123;"comments.0.votes":1&#125;&#125;)#增加第一个评论的投票数量&gt; db.blog.update(&#123;"comment.author": "John"&#125;, &#123;"$set": &#123;"comments.$.author": "Jim"&#125;&#125;)# $占位符，查询到评论中 作者名为John 的下标，更新为 Jim save函数save是一个shell函数,可以在文档不存在时插入，存在时更新，它只有一个参数：文档 如果这个文档含有”_id” 键，save会调用 upsert。否则会调用插入。 12345&gt; var x = db.foo.findOne()&gt; x.num = 42&gt; db.foo.save(x)# 免去了 update 的查询条件 删除remove: 从数据库永久删除文档，在传空对象调用，会删除一个集合内所有的文档 1&gt; db.blog.remove(&#123;title: &quot;my blog post&quot;&#125;) shell技巧12345&gt; db.help()# 查看数据库级别的入门命令&gt; db.foo.help()# 查看集合相关命令]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoose操作]]></title>
    <url>%2F2018%2F09%2F24%2Fmongoose%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[简单的 mongoose 示例1234567891011121314151617181920212223242526272829const mongoose = require('mongoose')mongoose.connect("mongodb://localhost:27017/study", &#123;useNewUrlParser:true&#125;, function(err)&#123; if(err)&#123; console.log('Connection Error:' + err) &#125;else&#123; console.log('Connection success!') &#125;&#125;)const UserSchema = new mongoose.Schema(&#123; nickname:&#123; type:String, default: 'new user' //在实例化 model 时，如果不传参则为默认值 &#125;&#125;)const User = mongoose.model('User', UserSchema)const user = new User(&#123; nickname:'ye'&#125;)// 保存到数据库user.save(err =&gt; &#123; if(err)&#123; return console.log(err) &#125; console.log(user.nickname) //打印保存后的值&#125;) 预定义修饰符 自定义：set修饰符 get修饰符 model 第二个参数会被直接传给 new mongoose.Schema 1234567891011121314151617181920212223const User = mongoose.model('User', &#123; nickname:&#123; type:String, trim: true //预定义修饰符 &#125;, blog:&#123; type:String, set:v =&gt; &#123; //自定义：set修饰符, new modal 传入的参数时执行 if(!v) return v; if(0 !== v.indexOf('http://') &amp;&amp; 0 !== v.indexOf('https://'))&#123; v = `http://$&#123;v&#125;` return v &#125; &#125;, get:v =&gt; &#123; //自定义：get修饰符, 数据存入数据库之后，取值时执行 if(!v) return v; if(0 !== v.indexOf('http://') &amp;&amp; 0 !== v.indexOf('https://'))&#123; v = `http://$&#123;v&#125;` return v &#125; &#125; &#125;&#125;) 虚拟属性有时我们不需要把值存取到数据库，可以通过其他的属性值计算，得到我们需要的值，这时可以利用到虚拟属性。 123456789101112131415const PersonSchema = new mongoose.Schema(&#123; firstName:String, lastName:String,&#125;)PersonSchema.virtual('fullName').get(function()&#123; return this.firstName + this.lastName&#125;)var Person = mongoose.model('Person', PersonSchema)var person = new Person(&#123; firstName:'ye', lastName:'wenxiang'&#125;)console.log(person.fullName) //yewenxiang 索引 唯一索引：检查是否唯一 辅助索引：增加查询速度 12345678910const BookSchema = new mongoose.Schema(&#123; isbn:&#123; type:Number, unique: true //唯一索引 &#125;, name:&#123; type: String, index: true, //辅助索引 &#125;&#125;) 模型的方法123456789101112// 自定义静态方法，在 BookSchema.findIsbn 上调用BookSchema.statics.findIsbn = function(isbn, cb)&#123; this.findOne(&#123;isbn&#125;, (err, doc)=&gt;&#123; cb(err, doc) &#125;)&#125;//自定义实例方法 在每个 new 出来的示例上调用BookSchema.methods.print = function()&#123; console.log(this.name) console.log(this.isbn)&#125; 数据校验数据在保存时检测是否符合规则。 预定义验证器 12345678910111213141516const orderSchema = new mongoose.Schema(&#123; count:&#123; type:Number, required: true, //必须传值 才能保存 max:1000, min:10, &#125;, status:&#123; type:String, enum:['created', 'success', 'failed'] //只能三个中选一个 才能保存 &#125;, dec:&#123; type:String, match: /Book/g, //正则验证，字符串中存在Book 才能保存 &#125;&#125;) 自定义验证器 12345678const orderSchema = new mongoose.Schema(&#123; desc: &#123; type:String, validate:(v) =&gt; &#123; return desc.length &gt;= 10 &#125; &#125;&#125;) 中间件 文档中间件：init/validate/save/remove 查询中间件：count/find/findOne/findOneAndRemove/findOneAndUpdate/update 集合交叉引用123456789101112131415161718192021222324252627282930313233343536373839404142const mongoose = require('mongoose');const Schema = mongoose.Schemaconst &#123;ObjectId, Mixed&#125; = Schema.Typesmongoose.connect("mongodb://localhost:27017/news", &#123;useNewUrlParser:true&#125;, function(err)&#123; if(err)&#123; console.log('Connection Error:' + err) &#125;else&#123; console.log('Connection success!') &#125;&#125;)const User = mongoose.model('User', &#123; user:String&#125;)const Artical = mongoose.model('Artical', &#123; title:String, author:&#123; type:ObjectId, ref:'User' &#125;&#125;)const user = new User(&#123; user:'ye'&#125;)const artical = new Artical(&#123; title: '标题', author: user&#125;)user.save(err=&gt;&#123; if(err) return console.log(err) console.log('user save success') artical.save(err =&gt; &#123; if(err) return console.log(err) console.log('artical save success') Artical.findOne(&#123;&#125;).populate('author').exec(function(err, doc)&#123; console.log(doc) &#125;) &#125;) &#125;)]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[puppeteer安装]]></title>
    <url>%2F2018%2F09%2F24%2Fpuppeteer%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[puppeteer 在执行安装的过程中需要执行install.js，这里会下载Chromium，翻墙也下载失败，导致安装不成功，官网建议是进行跳过，解决办法： 12&gt; npm i --save puppeteer --ignore-scripts#忽略 puppeteer js脚本的执行 手动下载 ChromiumChromium 下载 地址会根据系统来下载对应的 安装文件。 mac环境下载完毕后，把Chromium复制在项目的根目录 测试是否安装成功12345678910111213const puppeteer = require('puppeteer');(async () =&gt; &#123; const browser = await puppeteer.launch(&#123; executablePath: './chromium/Chromium.app/Contents/MacOS/Chromium', //自定义程序地址 &#125;); const page = await browser.newPage(); await page.goto('https://y.qq.com'); await page.screenshot(&#123;path:'yqq.png'&#125;); browser.close();&#125;)() puppeteer.launch 参数说明 executablePath：运行Chromium或Chrome可执行文件的路径 headless：true为不打开浏览器执行，浏览器运行在内存中，默认为true timeout： 等待浏览器实例启动的最长时间（以毫秒为单位）。默认为30000（30秒）。通过0禁用超时 args： 传递给浏览器实例的其他参数]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>puppeteer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 async 控制并发数量]]></title>
    <url>%2F2018%2F09%2F24%2Fasync%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344const eventproxy = require('eventproxy')const superagent = require('superagent')const cheerio = require('cheerio')const url = require('url')const async = require('async')const ep = new eventproxy()const cnodeUrl = 'https://cnodejs.org'const topicUrls = [];superagent.get(cnodeUrl) .end(function (err, res) &#123; if (err) &#123; return console.error(error) &#125; const topicUrls = []; const $ = cheerio.load(res.text); $('#topic_list .topic_title').each((index, item) =&gt; &#123; const href = url.resolve(cnodeUrl, $(item).attr('href')) topicUrls.push(href) &#125;) console.log(topicUrls.length) let count = 0; async.mapLimit(topicUrls, 6, function (url, callback) &#123; count++ console.log(`现在的并发数$&#123;count&#125;`) superagent.get(url) .end(function (err, res) &#123; if (err) return console.log(`fetch faild $&#123;err.status&#125;`) count-- callback(null, [url, res.text]) &#125;) &#125;, function (err, result) &#123; if (err) return console.log(err) result = result.map(item =&gt; &#123; const $ = cheerio.load(item[1]); return (&#123; title:$('.topic_full_title').text().trim(), url:item[0], comment1:$('.reply_content').eq(0).text().trim(), &#125;) &#125;) console.log(result) console.log(result.length) &#125;) &#125;)]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>async</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F09%2F24%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[语法介绍元字符 . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线或汉字 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 限定符 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 反义符 \W 匹配任意不是字母，数字，下划线，汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 参考 30分钟正则入门]]></content>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用命令]]></title>
    <url>%2F2018%2F09%2F24%2Fbash-command%2F</url>
    <content type="text"><![CDATA[升级react-native react-native-git-upgrade,直接升级到最新版本。升级到指定的版本 react-native-git-upgrade X.Y.Z。 升级时遇到的问题 ,删除掉 &quot;react-native-camera&quot;: &quot;git+https://github.com/lwansbrough/react-native-camera.git&quot;, 更新完成后，再安装 react-native-camera npm outdated 查看有哪些包可更新 npm-check -u 查看有哪些包可更新 npm list -g --depth 0 查看全局安装的包(depth 0 是只显示最顶层的包，不显示下面的依赖包) npm update 升级所有更新包,npm 2.6.1后才支持 yarn upgrade react-native-modalbox 升级包 which react-native 查看包的路径 mono --arch=32 Fiddler.exe 打开exe文件 lsof -i:端口号 kill -9 PID杀死进程 git 版本回滚 git reset --hard HEAD~0 forever start 你的脚本文件(如server.js) forever list 查看所有 forever 运行的进程 forever stop uid 停止运行指定 uid 的进程 control + D 断开 ssh 连接]]></content>
      <categories>
        <category>command</category>
      </categories>
      <tags>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo相关]]></title>
    <url>%2F2018%2F09%2F24%2Fhexo%2F</url>
    <content type="text"><![CDATA[1hexo clean &amp;&amp; hexo generate --deploy #自动部署]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>测试分类</category>
      </categories>
      <tags>
        <tag>hello</tag>
        <tag>world</tag>
      </tags>
  </entry>
</search>
